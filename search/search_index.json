{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tutorial","text":"<p>If you use this code in your research, please cite the following paper:</p> <p>[1] F.-C. Wang et al., Physical Review Letters 132, 086101 (2024)</p> <p>You are also welcome to contact me at <code>wfc@pku.edu.cn</code> for any questions or comments.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>A solid-solid phase transition establishes an atom-to-atom correspondence between crystal structures \\(\\mathcal A\\) and \\(\\mathcal B\\). Such correspondence is called a crystal-structure match (CSM) [1]. A CSM can be described by a pair of POSCAR files, which specifies how the lattice deforms from \\(\\mathcal A\\) to \\(\\mathcal B\\) and the correspondence between atoms in a supercell of \\(\\mathcal A\\) and those in \\(\\mathcal B\\).</p> <p>The main functions of <code>crystmatch</code> are as follows:</p> <ul> <li> <p>Enumeration:</p> <ul> <li>Provide a complete list of representative [1] CSMs between two given crystal structures, with user-specified upper bounds on the multiplicity [1] and root-mean-square strain (RMSS).</li> <li>(In progress) Provide a complete list of CSMs with user-specified upper bounds on the multiplicity, RMSS, and root-mean-square displacement (RMSD).</li> </ul> </li> <li> <p>Analysis:</p> <ul> <li>Read a CSM from a pair of POSCAR files, and save CSMs in the same format.</li> <li>Score CSMs by RMSS and RMSD.</li> <li>Benchmark a CSM by its deviation angle from an orientation relationship (OR).</li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Make sure you have Python 3.9 or later installed. You can check it by running:</p> <pre><code>$ python3 --version\n</code></pre> <p>Clone this repository and navigate to the directory where <code>setup.py</code> is located, run:</p> <pre><code>$ pip3 install .\n</code></pre> <p>Check whether <code>crystmatch</code> is successfully installed:</p> <pre><code>$ crystmatch --version\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>To run <code>crystmatch</code>, one of the following modes must be selected:</p> <ol> <li>Enumeration mode: Use <code>-E</code> or <code>--enumerate</code> to generate a list of CSMs, then perform preliminary analysis.</li> <li>Analysis mode: Use <code>-A</code> or <code>--analyze</code> to read CSM(s) from POSCAR files (or <code>CSM_LIST.npz</code> if provided), then perform detailed analysis. If <code>CSM_LIST.npz</code> is provided, you can export specific CSMs using <code>--export index1 [index2 ...]</code>.</li> </ol> <p>The initial and final crystal structures should be specified in the form of POSCAR files, unless in the analysis mode and <code>CSM_LIST.npz</code> is provided.</p> <p>If you don't specify any mode or crystal structures, <code>crystmatch</code> will ask for input.</p> <p>To see all available options, run:</p> <pre><code>$ crystmatch --help\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#enumerating-csms","title":"Enumerating CSMs","text":"<p>To generate a list of representative [1] CSMs between two crystal structures stored in <code>./fcc</code> and <code>./bcc</code>, with a maximum multiplicity of <code>4</code> and a maximum RMSS of <code>0.2</code>:</p> <pre><code>$ crystmatch --initial fcc --final bcc --enumeration 4 -0.2\n</code></pre> <p>We strongly recommend you to try small multiplicity (<code>2</code> or <code>4</code>) and RMSS between <code>0.2</code> and <code>0.5</code> first, and then gradually adjust these upper bounds to obtain desired results. Otherwise, the enumeration may take a very long time, or find no CSMs at all.</p> <p>The following files will be created in the <code>fcc-bcc-m4s0.20</code> directory:</p> <pre><code>fcc-bcc-m4s0.20/\n\u251c\u2500\u2500 CSM_LIST(fcc-bcc-m4s0.20).npz       # stores the enumerated CSMs and metadata.\n\u251c\u2500\u2500 rmsd-rmss-mu(fcc-bcc-m4s0.20).pdf   # shows the RMSD-RMSS distribution of the CSMs.\n\u2514\u2500\u2500 TABLE(fcc-bcc-m4s0.20).csv          # organizes the multiplicity, RMSS, and RMSD of each CSM.\n</code></pre>"},{"location":"#exporting-csms-from-an-npz-file","title":"Exporting CSMs from an NPZ file","text":"<p>To export the CSMs with indices <code>7</code> and <code>10</code> in <code>TABLE(foo).csv</code> from <code>CSM_LIST(foo).npz</code>:</p> <pre><code>$ crystmatch --analysis CSM_LIST(foo).npz --export 7 10\n</code></pre> <p>Two folders will be created in the <code>foo</code> directory, each containing a pair of POSCAR files representing the CSM as:</p> <pre><code>foo/\n\u251c\u2500\u2500 CSM_7(m3s0.15d0.83)/\n\u2502   \u251c\u2500\u2500 POSCAR_I\n\u2502   \u2514\u2500\u2500 POSCAR_F\n\u2514\u2500\u2500 CSM_10(m4s0.11d0.90)/\n    \u251c\u2500\u2500 POSCAR_I\n    \u2514\u2500\u2500 POSCAR_F\n</code></pre> <p>The values in the brackets represent the basic attributes of CSMs. For example, <code>m3s0.15d0.83</code> indicates a multiplicity of <code>3</code>, RMSS of <code>0.15</code>, and RMSD of <code>0.83</code>.</p>"},{"location":"#orientation-relationship-analysis","title":"Orientation relationship analysis","text":"<p>To benchmark CSMs in <code>CSM_LIST(foo).npz</code> by their deviation angles from the OR \\((111)_A\\parallel(110)_B,[1\\bar{1}0]_A\\parallel[001]_B\\):</p> <pre><code>$ crystmatch --analysis CSM_LIST(foo).npz --orientation 1 1 1 1 1 0 1 -1 0 0 0 1\n</code></pre> <p>The arguments after <code>--orientation</code> must be cartesian coordinates.</p> <p>The ORs are determined via the rotation-free manner by default, and you can also use <code>--fixusp</code> to determine ORs via the USF-fixed manner; see Ref. [1] for their definitions.</p>"},{"location":"api/","title":"Python API","text":""},{"location":"api/#data-structures","title":"Data Structures","text":"Type Structure Description <code>cryst</code> <code>(lattice, species, positions)</code> A crystal structure described by a primitive cell <code>lattice</code>, atomic species <code>species</code>, and fractional coordinates <code>positions</code>. Cell vectors are rows of <code>lattice</code>. <code>slm</code> <code>(hA, hB, q)</code> A sublattice match described by an integer-matrix triplet; see our paper."},{"location":"api/#available-functions","title":"Available Functions","text":""},{"location":"api/#crystmatch.enumeration","title":"<code>crystmatch.enumeration</code>","text":"<p>Enumerate SLMs and CSMs.</p>"},{"location":"api/#crystmatch.enumeration.create_common_supercell","title":"<code>create_common_supercell(crystA, crystB, slm)</code>","text":"<p>Create supercell structures representing A, (S^T S)^(1/2)S^(-1)B. Also return the half-distorted supercell and translation cell.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slm</code> <code>slm</code> <p>The SLM of the CSM.</p> required <p>Returns:</p> Name Type Description <code>crystA_sup</code> <code>cryst</code> <p>The supercell of the initial structure.</p> <code>crystB_sup_final</code> <code>cryst</code> <p>The supercell of the final structure, but deformed to have the same cell vectors as (S^T S)^(1/2) <code>crystA_sup</code> (rotation-free).</p> <code>c_sup_half</code> <code>(3, 3) array of floats</code> <p>The half-distorted supercell, i.e., (S^T S)^(1/4) <code>latticeA_sup</code> = (S^T S)^(-1/4) <code>latticeB_sup_final</code>.</p> <code>f_translate</code> <code>(3, 3) array of floats</code> <p>The translation cell (fractional coordinates) of the shuffle, i.e.,             gcd( (S^T S)^(1/4) <code>latticeA_sup</code> , (S^T S)^(-1/4) <code>latticeB_sup_final</code> ).</p>"},{"location":"api/#crystmatch.enumeration.enumerate_slm","title":"<code>enumerate_slm(crystA, crystB, mu, kappa_max, kappa=rmss, likelihood_ratio=100.0, print_detail=0)</code>","text":"<p>Enumerating all SLMs of multiplicity <code>mu</code> with <code>kappa</code> smaller than <code>kappa_max</code>.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>crystB</code> <code>cryst</code> <p>The final crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>mu</code> <code>int</code> <p>The multiplicity of SLMs to enumerate.</p> required <code>kappa_max</code> <code>float</code> <p>A positive threshold value of <code>kappa</code> to determine the range of singular values to generate.</p> required <code>kappa</code> <code>callable</code> <p>A function that quantifies the strain of a matrix according to its singular values.             By default, kappa([x1, x2, x3]) = sqrt(((x1-1)^2 + (x2-1)^2 + (x3-1)^2) / 3).</p> <code>rmss</code> <code>likelihood_ratio</code> <code>float</code> <p>The expected likelihood ratio of the enumeration being complete and incomplete. Default is 1e2.</p> <code>100.0</code> <code>print_detail</code> <code>int</code> <p>The level of detail of printing. 0 means no print.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>slmlist</code> <code>list of slm</code> <p>Contains triplets of integer matrices like <code>(hA, hB, q)</code>, representing inequivalent SLMs.</p>"},{"location":"api/#crystmatch.enumeration.equiv_class_representative","title":"<code>equiv_class_representative(slm, gA, gB)</code>","text":"<p>The representative of the equivalence class of <code>s</code>.</p> <p>Parameters:</p> Name Type Description Default <code>slm</code> <code>slm</code> <p><code>(hA, hB, q)</code>, representing a SLM.</p> required <code>gA</code> <code>(..., 3, 3) array of ints</code> <p>The rotation group of the initial crystal structure, whose elements are             integer matrices under fractional coordinates.</p> required <code>gB</code> <code>(..., 3, 3) array of ints</code> <p>The rotation group of the final crystal structure, whose elements are             integer matrices under fractional coordinates.</p> required <p>Returns:</p> Name Type Description <code>ss</code> <code>slm</code> <p>The representative of the equivalence class of <code>s</code>.</p> <code>len_cl</code> <code>int</code> <p>The size of the equivalence class of <code>s</code>.</p>"},{"location":"api/#crystmatch.enumeration.get_pure_rotation","title":"<code>get_pure_rotation(cryst, symprec=1e-05)</code>","text":"<p>Find all pure rotations appeared in the space group of <code>cryst</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cryst</code> <code>3 - tuple</code> <p><code>(lattice, species, positions)</code>, representing the crystal structure, usually obtained by <code>load_poscar</code>.</p> required <p>Returns:</p> Name Type Description <code>g</code> <code>(..., 3, 3) array of ints</code> <p>A point group of the first kind, containing all pure rotations appeared in the space group of <code>cryst</code>,             elements of which are integer matrices (under fractional coordinates).</p>"},{"location":"api/#crystmatch.enumeration.hnf_int","title":"<code>hnf_int(m)</code>","text":"<p>Decompose square integer matrix <code>m</code> into product of HNF matrix <code>h</code> and unimodular matrix <code>q</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>(N, N) array of ints</code> <p>The integer matrix to decompose, with positive determinant.</p> required <p>Returns:</p> Name Type Description <code>h</code> <code>(N, N) array of ints</code> <p>The column-style Hermite normal form of <code>m</code>.</p> <code>q</code> <code>(N, N) array of ints</code> <p>The unimodular matrix satisfying <code>m</code> = <code>h @ q</code>.</p>"},{"location":"api/#crystmatch.enumeration.hnf_list","title":"<code>hnf_list(det)</code>","text":"<p>Enumerate all 3*3 column Hermite normal forms (HNFs) with given determinant.</p> <p>Parameters:</p> Name Type Description Default <code>det</code> <code>int</code> <p>The determinant of HNFs.</p> required <p>Returns:</p> Name Type Description <code>l</code> <code>(..., 3, 3) array of ints</code> <p>Contains all HNFs with determinant <code>det</code>.</p>"},{"location":"api/#crystmatch.enumeration.hnf_rational","title":"<code>hnf_rational(m, max_divisor=10000)</code>","text":"<p>The Hermite normal form (HNF) of full-row-rank rational matrix <code>m</code> (not necessarily square or integer).</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>(M, N) array_like, M &lt;= N</code> <p>The full-row-rank rational matrix to reduce.</p> required <code>max_divisor</code> <code>int</code> <p>A positive integer. The least common multiple of all divisors in <code>m</code> should not be greater than <code>max_divisor</code>.</p> <code>10000</code> <p>Returns:</p> Name Type Description <code>h</code> <code>(M, N) array</code> <p>The HNF of <code>m</code> obtained via elementary column operations over integers.</p>"},{"location":"api/#crystmatch.enumeration.int_arrays_to_pair","title":"<code>int_arrays_to_pair(crystA, crystB, slm, p, ks, centered=True)</code>","text":"<p>Convert the integer arrays representation <code>(slm, p, translations)</code> of a CSM to a pair of crysts.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slm</code> <code>slm</code> <p>The SLM of the CSM.</p> required <code>p</code> <code>(Z, ) array of ints</code> <p>The permutaion of the shuffle.</p> required <code>ks</code> <code>(3, Z) array of ints</code> <p>The lattice-vector translations of the shuffle.</p> required <code>centered</code> <code>bool</code> <p>Whether to make the centers of <code>crystA_sup</code> and <code>crystB_sup_final</code> coincide. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>crystA_sup</code> <code>cryst</code> <p>The initial structure, whose lattice vectors and atoms are matched to <code>crystB_sup</code> according to the CSM.</p> <code>crystB_sup_final</code> <code>cryst</code> <p>The final structure, whose lattice vectors and atoms are matched to <code>crystA_sup</code> according to the CSM, with rotation-free orientation.</p>"},{"location":"api/#crystmatch.enumeration.int_fact","title":"<code>int_fact(n)</code>","text":"<p>Factorize positive integer <code>n</code> into products of two integers.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The integer to be factorized.</p> required <p>Returns:</p> Name Type Description <code>l</code> <code>list of 2-tuples of ints</code> <p>Contains all <code>(a, b)</code> such that a*b=n.</p>"},{"location":"api/#crystmatch.enumeration.int_vec_inside","title":"<code>int_vec_inside(c)</code>","text":"<p>Integer vectors inside the cell <code>c</code> whose elements are integers.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array of ints</code> <p>A matrix whose columns are integer cell vectors.</p> required <p>Returns:</p> Name Type Description <code>v_int</code> <code>(3, ...) array of ints</code> <p>Its columns are vectors satisfying <code>v = c @ k</code>, where 0 &lt;= <code>k[0]</code>, <code>k[1]</code>, <code>k[2]</code> &lt; 1.</p>"},{"location":"api/#crystmatch.enumeration.load_poscar","title":"<code>load_poscar(filename, to_primitive=True, symprec=1e-05)</code>","text":"<p>Load the crystal structure from a POSCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the POSCAR file to be read.</p> required <code>to_primitive</code> <code>bool</code> <p>Using the primitive cell instead of the cell given by the POSCAR file. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>cryst</code> <code>cryst</code> <p>The loaded crystal structure, consisting of the lattice vectors, species, and positions.</p> <code>lattice</code> <code>(3, 3) array</code> <p>In accord with the POSCAR format and the scaling factor is multiplied.</p> <code>species</code> <code>(N,) array of strs</code> <p>Respective species of the ions.</p> <code>positions</code> <code>(N, 3) array</code> <p>In accord with the POSCAR format ('Direct' mode).</p>"},{"location":"api/#crystmatch.enumeration.matrix_gcd","title":"<code>matrix_gcd(m1, m2, max_divisor=10000)</code>","text":"<p>Return a greatest common divisor of rational matrices <code>m1</code> and <code>m2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m1</code> <code>(3, 3) array_like</code> <p>Nonsingular rational matrices.</p> required <code>m2</code> <code>(3, 3) array_like</code> <p>Nonsingular rational matrices.</p> required <code>max_divisor</code> <code>int</code> <p>A positive integer. The least common multiple of all divisors in <code>m</code> should not be greater than <code>max_divisor</code>.</p> <code>10000</code> <p>Returns:</p> Name Type Description <code>d</code> <code>(3, 3) array</code> <p>The greatest common divisor of <code>m1</code> and <code>m2</code> in Hermite normal form.</p>"},{"location":"api/#crystmatch.enumeration.matrix_lcm","title":"<code>matrix_lcm(m1, m2)</code>","text":"<p>Return a least common multiple of integer matrices <code>m1</code> and <code>m2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m1</code> <code>(3, 3) array_like</code> <p>Nonsingular integer matrices.</p> required <code>m2</code> <code>(3, 3) array_like</code> <p>Nonsingular integer matrices.</p> required <p>Returns:</p> Name Type Description <code>m</code> <code>(3, 3) array</code> <p>The least common multiple of <code>m1</code> and <code>m2</code> in Hermite normal form.</p>"},{"location":"api/#crystmatch.enumeration.minimize_rmsd","title":"<code>minimize_rmsd(crystA, crystB, slm, n_grid=5)</code>","text":"<p>Minimize the RMSD with fixed SLM, variable permutation, overall and lattice-vector translations.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>crystB</code> <code>cryst</code> <p>The final crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>slm</code> <code>slm</code> <p>Triplets of integer matrices like <code>(hA, hB, q)</code>, representing a SLM.</p> required <code>n_grid</code> <code>int</code> <p>The number of grid points for translation. Default is 5.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>rmsd</code> <code>float</code> <p>The minimum atomic displacement (RMSD) between (S^T S)^(1/4) <code>crystA_sup</code> and (S^T S)^(-1/4) <code>crystB_sup</code>.</p> <code>p</code> <code>(Z, ) array of ints</code> <p>The permutation of the atoms in <code>pB_sup</code> that minimizes the RMSD.</p> <code>ks</code> <code>(3, Z) array of ints</code> <p>The lattice-vector translations (fractional coordinates) of the atoms in <code>pB_sup[:,p]</code> that minimizes the RMSD.</p> <code>t0</code> <code>(3, ) array of floats</code> <p>The overall translation on <code>pB</code> that minimizes the RMSD.</p>"},{"location":"api/#crystmatch.enumeration.minimize_rmsd_t","title":"<code>minimize_rmsd_t(c, species, pA, pB)</code>","text":"<p>Minimize the RMSD with fixed SLM, overall translation, variable permutation and lattice-vector translations.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array</code> <p>The matrix whose columns are cell vectors of both crystal structures.</p> required <code>species</code> <code>(N,) array of strs</code> <p>The array that specifies the type of each ion.</p> required <code>pA</code> <code>(3, N) array</code> <p>The matrices whose columns are fractional coordinates of atoms.</p> required <code>pB</code> <code>(3, N) array</code> <p>The matrices whose columns are fractional coordinates of atoms.</p> required <p>Returns:</p> Name Type Description <code>rmsd</code> <code>float</code> <p>The minimized RMSD.</p> <code>p</code> <code>(Z, ) array of ints</code> <p>The permutation of the atoms in <code>pB</code> that minimizes the RMSD.</p> <code>ks</code> <code>(3, Z) array of ints</code> <p>The lattice-vector translations of the atoms in <code>pB[:,p]</code> that minimizes the RMSD.</p>"},{"location":"api/#crystmatch.enumeration.minimize_rmsd_tp","title":"<code>minimize_rmsd_tp(c, pA, pB)</code>","text":"<p>Minimize the RMSD with fixed SLM, overall translation, permutation, and variable lattice-vector translations.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array</code> <p>The matrix whose columns are cell vectors of both crystal structures.</p> required <code>pA</code> <code>(3, N) array</code> <p>The matrices whose columns are fractional coordinates of atoms.</p> required <code>pB</code> <code>(3, N) array</code> <p>The matrices whose columns are fractional coordinates of atoms.</p> required <p>Returns:</p> Name Type Description <code>rmsd</code> <code>float</code> <p>The minimized RMSD.</p> <code>ks</code> <code>(3, Z) array of ints</code> <p>The lattice-vector translations (fractional coordinates) of the atoms in <code>pB</code> that minimizes the RMSD.</p>"},{"location":"api/#crystmatch.enumeration.niggli_cell","title":"<code>niggli_cell(c)</code>","text":"<p>Reduce cell <code>c</code> to its Niggli cell.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array</code> <p>The cell to be reduced, whose columns are cell vectors.</p> required <p>Returns:</p> Name Type Description <code>cc</code> <code>(3, 3) array</code> <p>The Niggli cell, with shortest right-handed cell vectors.</p> <code>q</code> <code>(3, 3) array of ints</code> <p>The unimodular matrix satisfying <code>cc = c @ q</code>.</p>"},{"location":"api/#crystmatch.enumeration.rmss","title":"<code>rmss(x)</code>","text":"<p>Root-mean-square strain of given singular values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>(..., 3) array</code> <p>The singular values of 3*3 matrices.</p> required <p>Returns:</p> Name Type Description <code>rms_strain</code> <code>(...) array</code> <p>Root-mean-square of <code>x - 1</code>.</p>"},{"location":"api/#crystmatch.enumeration.save_poscar","title":"<code>save_poscar(filename, cryst, crystname=None)</code>","text":"<p>Save the crystal structure to a POSCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save, must not already exist in current directory.</p> required <code>cryst</code> <code>cryst</code> <p>The crystal structure to be saved, consisting of the lattice vectors, species, and positions.</p> required <code>crystname</code> <code>str</code> <p>A system description to write to the comment line of the POSCAR file. If <code>crystname = None</code>, <code>filename</code> will be used.</p> <code>None</code>"},{"location":"api/#crystmatch.enumeration.vector_reduce","title":"<code>vector_reduce(v, divisors)</code>","text":"<p>Minimizing the norm of <code>v</code> by adding and subtracting columns of <code>divisors</code>.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>(N,) array</code> <p>The vector to be reduced.</p> required <code>divisors</code> <code>(N, ...) array</code> <p>The vectors used to translate <code>v</code>.</p> required <p>Returns:</p> Name Type Description <code>vv</code> <code>(N,) array</code> <p>The reduced <code>v</code> with minimum Euclidean norm.</p>"},{"location":"api/#crystmatch.analysis","title":"<code>crystmatch.analysis</code>","text":"<p>Analyze and visualize CSMs.</p>"},{"location":"api/#crystmatch.analysis.compare_orientation","title":"<code>compare_orientation(crystA, crystB, slmlist, r, fix_usp=False)</code>","text":"<p>Calculate how much each SLM in <code>slmlist</code> differ from a given orientation relationship.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>crystB</code> <code>cryst</code> <p>The final crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>slmlist</code> <code>list of slm</code> <p>A list of SLMs, each represented by a triplet of integer matrices like <code>(hA, hB, q)</code>.</p> required <code>r</code> <code>(3, 3) array</code> <p>A rotation matrix representing the given orientation relationship.</p> required <code>fix_usp</code> <code>bool</code> <p>Whether to fix the uniformed scaled plane. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>anglelist</code> <code>(...,) array</code> <p>Contains rotation angles that measure the difference of each SLM and the given orientation.</p>"},{"location":"api/#crystmatch.analysis.create_common_supercell","title":"<code>create_common_supercell(crystA, crystB, slm)</code>","text":"<p>Create supercell structures representing A, (S^T S)^(1/2)S^(-1)B. Also return the half-distorted supercell and translation cell.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slm</code> <code>slm</code> <p>The SLM of the CSM.</p> required <p>Returns:</p> Name Type Description <code>crystA_sup</code> <code>cryst</code> <p>The supercell of the initial structure.</p> <code>crystB_sup_final</code> <code>cryst</code> <p>The supercell of the final structure, but deformed to have the same cell vectors as (S^T S)^(1/2) <code>crystA_sup</code> (rotation-free).</p> <code>c_sup_half</code> <code>(3, 3) array of floats</code> <p>The half-distorted supercell, i.e., (S^T S)^(1/4) <code>latticeA_sup</code> = (S^T S)^(-1/4) <code>latticeB_sup_final</code>.</p> <code>f_translate</code> <code>(3, 3) array of floats</code> <p>The translation cell (fractional coordinates) of the shuffle, i.e.,             gcd( (S^T S)^(1/4) <code>latticeA_sup</code> , (S^T S)^(-1/4) <code>latticeB_sup_final</code> ).</p>"},{"location":"api/#crystmatch.analysis.deform_distance","title":"<code>deform_distance(slmlist, s0, crystA, crystB)</code>","text":"<p>The Frobenius distance between deformation gradients.</p> <p>Parameters:</p> Name Type Description Default <code>slmlist</code> <code>list of slm</code> <p>A list of SLMs, each represented by a triplet of integer matrices like <code>(hA, hB, q)</code>.</p> required <code>s0</code> <code>slm</code> <p><code>(hA, hB, q)</code>, representing a SLM.</p> required <code>crystA</code> <code>cryst</code> <p><code>(lattice, species, positions)</code>, representing the crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>crystB</code> <code>cryst</code> <p><code>(lattice, species, positions)</code>, representing the crystal structure, usually obtained by <code>load_poscar</code>.</p> required <p>Returns:</p> Name Type Description <code>dlist</code> <code>(...,) array</code> <p>Contains Frobenius distances from <code>slmlist</code> to <code>s0</code>, where equivalent SLMs coincide.</p>"},{"location":"api/#crystmatch.analysis.get_pure_rotation","title":"<code>get_pure_rotation(cryst, symprec=1e-05)</code>","text":"<p>Find all pure rotations appeared in the space group of <code>cryst</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cryst</code> <code>3 - tuple</code> <p><code>(lattice, species, positions)</code>, representing the crystal structure, usually obtained by <code>load_poscar</code>.</p> required <p>Returns:</p> Name Type Description <code>g</code> <code>(..., 3, 3) array of ints</code> <p>A point group of the first kind, containing all pure rotations appeared in the space group of <code>cryst</code>,             elements of which are integer matrices (under fractional coordinates).</p>"},{"location":"api/#crystmatch.analysis.hnf_int","title":"<code>hnf_int(m)</code>","text":"<p>Decompose square integer matrix <code>m</code> into product of HNF matrix <code>h</code> and unimodular matrix <code>q</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>(N, N) array of ints</code> <p>The integer matrix to decompose, with positive determinant.</p> required <p>Returns:</p> Name Type Description <code>h</code> <code>(N, N) array of ints</code> <p>The column-style Hermite normal form of <code>m</code>.</p> <code>q</code> <code>(N, N) array of ints</code> <p>The unimodular matrix satisfying <code>m</code> = <code>h @ q</code>.</p>"},{"location":"api/#crystmatch.analysis.hnf_list","title":"<code>hnf_list(det)</code>","text":"<p>Enumerate all 3*3 column Hermite normal forms (HNFs) with given determinant.</p> <p>Parameters:</p> Name Type Description Default <code>det</code> <code>int</code> <p>The determinant of HNFs.</p> required <p>Returns:</p> Name Type Description <code>l</code> <code>(..., 3, 3) array of ints</code> <p>Contains all HNFs with determinant <code>det</code>.</p>"},{"location":"api/#crystmatch.analysis.hnf_rational","title":"<code>hnf_rational(m, max_divisor=10000)</code>","text":"<p>The Hermite normal form (HNF) of full-row-rank rational matrix <code>m</code> (not necessarily square or integer).</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>(M, N) array_like, M &lt;= N</code> <p>The full-row-rank rational matrix to reduce.</p> required <code>max_divisor</code> <code>int</code> <p>A positive integer. The least common multiple of all divisors in <code>m</code> should not be greater than <code>max_divisor</code>.</p> <code>10000</code> <p>Returns:</p> Name Type Description <code>h</code> <code>(M, N) array</code> <p>The HNF of <code>m</code> obtained via elementary column operations over integers.</p>"},{"location":"api/#crystmatch.analysis.int_arrays_to_pair","title":"<code>int_arrays_to_pair(crystA, crystB, slm, p, ks, centered=True)</code>","text":"<p>Convert the integer arrays representation <code>(slm, p, translations)</code> of a CSM to a pair of crysts.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slm</code> <code>slm</code> <p>The SLM of the CSM.</p> required <code>p</code> <code>(Z, ) array of ints</code> <p>The permutaion of the shuffle.</p> required <code>ks</code> <code>(3, Z) array of ints</code> <p>The lattice-vector translations of the shuffle.</p> required <code>centered</code> <code>bool</code> <p>Whether to make the centers of <code>crystA_sup</code> and <code>crystB_sup_final</code> coincide. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>crystA_sup</code> <code>cryst</code> <p>The initial structure, whose lattice vectors and atoms are matched to <code>crystB_sup</code> according to the CSM.</p> <code>crystB_sup_final</code> <code>cryst</code> <p>The final structure, whose lattice vectors and atoms are matched to <code>crystA_sup</code> according to the CSM, with rotation-free orientation.</p>"},{"location":"api/#crystmatch.analysis.int_fact","title":"<code>int_fact(n)</code>","text":"<p>Factorize positive integer <code>n</code> into products of two integers.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The integer to be factorized.</p> required <p>Returns:</p> Name Type Description <code>l</code> <code>list of 2-tuples of ints</code> <p>Contains all <code>(a, b)</code> such that a*b=n.</p>"},{"location":"api/#crystmatch.analysis.int_vec_inside","title":"<code>int_vec_inside(c)</code>","text":"<p>Integer vectors inside the cell <code>c</code> whose elements are integers.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array of ints</code> <p>A matrix whose columns are integer cell vectors.</p> required <p>Returns:</p> Name Type Description <code>v_int</code> <code>(3, ...) array of ints</code> <p>Its columns are vectors satisfying <code>v = c @ k</code>, where 0 &lt;= <code>k[0]</code>, <code>k[1]</code>, <code>k[2]</code> &lt; 1.</p>"},{"location":"api/#crystmatch.analysis.load_poscar","title":"<code>load_poscar(filename, to_primitive=True, symprec=1e-05)</code>","text":"<p>Load the crystal structure from a POSCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the POSCAR file to be read.</p> required <code>to_primitive</code> <code>bool</code> <p>Using the primitive cell instead of the cell given by the POSCAR file. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>cryst</code> <code>cryst</code> <p>The loaded crystal structure, consisting of the lattice vectors, species, and positions.</p> <code>lattice</code> <code>(3, 3) array</code> <p>In accord with the POSCAR format and the scaling factor is multiplied.</p> <code>species</code> <code>(N,) array of strs</code> <p>Respective species of the ions.</p> <code>positions</code> <code>(N, 3) array</code> <p>In accord with the POSCAR format ('Direct' mode).</p>"},{"location":"api/#crystmatch.analysis.matrix_gcd","title":"<code>matrix_gcd(m1, m2, max_divisor=10000)</code>","text":"<p>Return a greatest common divisor of rational matrices <code>m1</code> and <code>m2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m1</code> <code>(3, 3) array_like</code> <p>Nonsingular rational matrices.</p> required <code>m2</code> <code>(3, 3) array_like</code> <p>Nonsingular rational matrices.</p> required <code>max_divisor</code> <code>int</code> <p>A positive integer. The least common multiple of all divisors in <code>m</code> should not be greater than <code>max_divisor</code>.</p> <code>10000</code> <p>Returns:</p> Name Type Description <code>d</code> <code>(3, 3) array</code> <p>The greatest common divisor of <code>m1</code> and <code>m2</code> in Hermite normal form.</p>"},{"location":"api/#crystmatch.analysis.matrix_lcm","title":"<code>matrix_lcm(m1, m2)</code>","text":"<p>Return a least common multiple of integer matrices <code>m1</code> and <code>m2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m1</code> <code>(3, 3) array_like</code> <p>Nonsingular integer matrices.</p> required <code>m2</code> <code>(3, 3) array_like</code> <p>Nonsingular integer matrices.</p> required <p>Returns:</p> Name Type Description <code>m</code> <code>(3, 3) array</code> <p>The least common multiple of <code>m1</code> and <code>m2</code> in Hermite normal form.</p>"},{"location":"api/#crystmatch.analysis.multiplicity","title":"<code>multiplicity(crystA, crystB, slmlist)</code>","text":"<p>Return multiplicities of elements in <code>slmlist</code>.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>crystB</code> <code>cryst</code> <p>The final crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>slmlist</code> <code>list of slm</code> <p>A list of SLMs, each represented by a triplet of integer matrices like <code>(hA, hB, q)</code>.</p> required <p>Returns:</p> Name Type Description <code>mu</code> <code>int or (...,) array of ints</code> <p>Multiplicities of each SLM in <code>slmlist</code>.</p>"},{"location":"api/#crystmatch.analysis.niggli_cell","title":"<code>niggli_cell(c)</code>","text":"<p>Reduce cell <code>c</code> to its Niggli cell.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array</code> <p>The cell to be reduced, whose columns are cell vectors.</p> required <p>Returns:</p> Name Type Description <code>cc</code> <code>(3, 3) array</code> <p>The Niggli cell, with shortest right-handed cell vectors.</p> <code>q</code> <code>(3, 3) array of ints</code> <p>The unimodular matrix satisfying <code>cc = c @ q</code>.</p>"},{"location":"api/#crystmatch.analysis.orientation_relation","title":"<code>orientation_relation(vi, vf, wi, wf)</code>","text":"<p>Rotation matrix <code>r</code> such that <code>r @ vi</code> || <code>vf</code> and <code>r @ wi</code> || <code>wf</code>.</p> <p>Parameters:</p> Name Type Description Default <code>vi</code> <code>(3,) array_like</code> <p>Vectors (cartesian coordinates) that satisfy <code>r @ vi</code> || <code>vf</code>.</p> required <code>vf</code> <code>(3,) array_like</code> <p>Vectors (cartesian coordinates) that satisfy <code>r @ vi</code> || <code>vf</code>.</p> required <code>wi</code> <code>(3,) array_like</code> <p>Vectors (cartesian coordinates) that satisfy <code>r @ wi</code> || <code>wf</code>.</p> required <code>wf</code> <code>(3,) array_like</code> <p>Vectors (cartesian coordinates) that satisfy <code>r @ wi</code> || <code>wf</code>.</p> required <p>Returns:</p> Name Type Description <code>r</code> <code>(3, 3) array</code> <p>A rotation matrix representing the given orientation relationship.</p>"},{"location":"api/#crystmatch.analysis.rmss","title":"<code>rmss(x)</code>","text":"<p>Root-mean-square strain of given singular values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>(..., 3) array</code> <p>The singular values of 3*3 matrices.</p> required <p>Returns:</p> Name Type Description <code>rms_strain</code> <code>(...) array</code> <p>Root-mean-square of <code>x - 1</code>.</p>"},{"location":"api/#crystmatch.analysis.save_poscar","title":"<code>save_poscar(filename, cryst, crystname=None)</code>","text":"<p>Save the crystal structure to a POSCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save, must not already exist in current directory.</p> required <code>cryst</code> <code>cryst</code> <p>The crystal structure to be saved, consisting of the lattice vectors, species, and positions.</p> required <code>crystname</code> <code>str</code> <p>A system description to write to the comment line of the POSCAR file. If <code>crystname = None</code>, <code>filename</code> will be used.</p> <code>None</code>"},{"location":"api/#crystmatch.analysis.scatter_colored","title":"<code>scatter_colored(filename, rmsslist, rmsdlist, colorlist, cmap=plt.cm.get_cmap('viridis'), cbarlabel=None)</code>","text":"<p>Scatter plot of the CSMs with colorbar.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the saved plot.</p> required <code>rmsslist</code> <code>(N,) array_like</code> <p>The root-mean-square strain of each CSM.</p> required <code>rmsdlist</code> <code>(N,) array_like</code> <p>The root-mean-square distance of each CSM.</p> required <code>colorlist</code> <code>(N,) array_like</code> <p>Some quantity of each CSM, which is to be colored.</p> required <code>cmap</code> <code>`matplotlib.colors.Colormap`</code> <p>The colormap to use. Default is <code>plt.cm.get_cmap('viridis')</code>.</p> <code>get_cmap('viridis')</code> <code>cbarlabel</code> <code>str</code> <p>The label of the colorbar. Default is None, in which case the filename is used.</p> <code>None</code>"},{"location":"api/#crystmatch.analysis.sing_val","title":"<code>sing_val(crystA, crystB, slmlist)</code>","text":"<p>Return singular values of elements in <code>slmlist</code>.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>crystB</code> <code>cryst</code> <p>The final crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>slmlist</code> <code>list of slm</code> <p>A list of SLMs, each represented by a triplet of integer matrices like <code>(hA, hB, q)</code>.</p> required <p>Returns:</p> Name Type Description <code>sv</code> <code>(..., 3) array</code> <p>Contains singular values of each SLM in <code>slmlist</code>.</p>"},{"location":"api/#crystmatch.analysis.vector_reduce","title":"<code>vector_reduce(v, divisors)</code>","text":"<p>Minimizing the norm of <code>v</code> by adding and subtracting columns of <code>divisors</code>.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>(N,) array</code> <p>The vector to be reduced.</p> required <code>divisors</code> <code>(N, ...) array</code> <p>The vectors used to translate <code>v</code>.</p> required <p>Returns:</p> Name Type Description <code>vv</code> <code>(N,) array</code> <p>The reduced <code>v</code> with minimum Euclidean norm.</p>"},{"location":"api/#crystmatch.utilities","title":"<code>crystmatch.utilities</code>","text":"<p>Load/save crystal structures and CSMs from/to files.</p>"},{"location":"api/#crystmatch.utilities.create_common_supercell","title":"<code>create_common_supercell(crystA, crystB, slm)</code>","text":"<p>Create supercell structures representing A, (S^T S)^(1/2)S^(-1)B. Also return the half-distorted supercell and translation cell.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slm</code> <code>slm</code> <p>The SLM of the CSM.</p> required <p>Returns:</p> Name Type Description <code>crystA_sup</code> <code>cryst</code> <p>The supercell of the initial structure.</p> <code>crystB_sup_final</code> <code>cryst</code> <p>The supercell of the final structure, but deformed to have the same cell vectors as (S^T S)^(1/2) <code>crystA_sup</code> (rotation-free).</p> <code>c_sup_half</code> <code>(3, 3) array of floats</code> <p>The half-distorted supercell, i.e., (S^T S)^(1/4) <code>latticeA_sup</code> = (S^T S)^(-1/4) <code>latticeB_sup_final</code>.</p> <code>f_translate</code> <code>(3, 3) array of floats</code> <p>The translation cell (fractional coordinates) of the shuffle, i.e.,             gcd( (S^T S)^(1/4) <code>latticeA_sup</code> , (S^T S)^(-1/4) <code>latticeB_sup_final</code> ).</p>"},{"location":"api/#crystmatch.utilities.get_pure_rotation","title":"<code>get_pure_rotation(cryst, symprec=1e-05)</code>","text":"<p>Find all pure rotations appeared in the space group of <code>cryst</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cryst</code> <code>3 - tuple</code> <p><code>(lattice, species, positions)</code>, representing the crystal structure, usually obtained by <code>load_poscar</code>.</p> required <p>Returns:</p> Name Type Description <code>g</code> <code>(..., 3, 3) array of ints</code> <p>A point group of the first kind, containing all pure rotations appeared in the space group of <code>cryst</code>,             elements of which are integer matrices (under fractional coordinates).</p>"},{"location":"api/#crystmatch.utilities.hnf_int","title":"<code>hnf_int(m)</code>","text":"<p>Decompose square integer matrix <code>m</code> into product of HNF matrix <code>h</code> and unimodular matrix <code>q</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>(N, N) array of ints</code> <p>The integer matrix to decompose, with positive determinant.</p> required <p>Returns:</p> Name Type Description <code>h</code> <code>(N, N) array of ints</code> <p>The column-style Hermite normal form of <code>m</code>.</p> <code>q</code> <code>(N, N) array of ints</code> <p>The unimodular matrix satisfying <code>m</code> = <code>h @ q</code>.</p>"},{"location":"api/#crystmatch.utilities.hnf_list","title":"<code>hnf_list(det)</code>","text":"<p>Enumerate all 3*3 column Hermite normal forms (HNFs) with given determinant.</p> <p>Parameters:</p> Name Type Description Default <code>det</code> <code>int</code> <p>The determinant of HNFs.</p> required <p>Returns:</p> Name Type Description <code>l</code> <code>(..., 3, 3) array of ints</code> <p>Contains all HNFs with determinant <code>det</code>.</p>"},{"location":"api/#crystmatch.utilities.hnf_rational","title":"<code>hnf_rational(m, max_divisor=10000)</code>","text":"<p>The Hermite normal form (HNF) of full-row-rank rational matrix <code>m</code> (not necessarily square or integer).</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>(M, N) array_like, M &lt;= N</code> <p>The full-row-rank rational matrix to reduce.</p> required <code>max_divisor</code> <code>int</code> <p>A positive integer. The least common multiple of all divisors in <code>m</code> should not be greater than <code>max_divisor</code>.</p> <code>10000</code> <p>Returns:</p> Name Type Description <code>h</code> <code>(M, N) array</code> <p>The HNF of <code>m</code> obtained via elementary column operations over integers.</p>"},{"location":"api/#crystmatch.utilities.int_arrays_to_pair","title":"<code>int_arrays_to_pair(crystA, crystB, slm, p, ks, centered=True)</code>","text":"<p>Convert the integer arrays representation <code>(slm, p, translations)</code> of a CSM to a pair of crysts.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slm</code> <code>slm</code> <p>The SLM of the CSM.</p> required <code>p</code> <code>(Z, ) array of ints</code> <p>The permutaion of the shuffle.</p> required <code>ks</code> <code>(3, Z) array of ints</code> <p>The lattice-vector translations of the shuffle.</p> required <code>centered</code> <code>bool</code> <p>Whether to make the centers of <code>crystA_sup</code> and <code>crystB_sup_final</code> coincide. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>crystA_sup</code> <code>cryst</code> <p>The initial structure, whose lattice vectors and atoms are matched to <code>crystB_sup</code> according to the CSM.</p> <code>crystB_sup_final</code> <code>cryst</code> <p>The final structure, whose lattice vectors and atoms are matched to <code>crystA_sup</code> according to the CSM, with rotation-free orientation.</p>"},{"location":"api/#crystmatch.utilities.int_fact","title":"<code>int_fact(n)</code>","text":"<p>Factorize positive integer <code>n</code> into products of two integers.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The integer to be factorized.</p> required <p>Returns:</p> Name Type Description <code>l</code> <code>list of 2-tuples of ints</code> <p>Contains all <code>(a, b)</code> such that a*b=n.</p>"},{"location":"api/#crystmatch.utilities.int_vec_inside","title":"<code>int_vec_inside(c)</code>","text":"<p>Integer vectors inside the cell <code>c</code> whose elements are integers.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array of ints</code> <p>A matrix whose columns are integer cell vectors.</p> required <p>Returns:</p> Name Type Description <code>v_int</code> <code>(3, ...) array of ints</code> <p>Its columns are vectors satisfying <code>v = c @ k</code>, where 0 &lt;= <code>k[0]</code>, <code>k[1]</code>, <code>k[2]</code> &lt; 1.</p>"},{"location":"api/#crystmatch.utilities.load_poscar","title":"<code>load_poscar(filename, to_primitive=True, symprec=1e-05)</code>","text":"<p>Load the crystal structure from a POSCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the POSCAR file to be read.</p> required <code>to_primitive</code> <code>bool</code> <p>Using the primitive cell instead of the cell given by the POSCAR file. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>cryst</code> <code>cryst</code> <p>The loaded crystal structure, consisting of the lattice vectors, species, and positions.</p> <code>lattice</code> <code>(3, 3) array</code> <p>In accord with the POSCAR format and the scaling factor is multiplied.</p> <code>species</code> <code>(N,) array of strs</code> <p>Respective species of the ions.</p> <code>positions</code> <code>(N, 3) array</code> <p>In accord with the POSCAR format ('Direct' mode).</p>"},{"location":"api/#crystmatch.utilities.matrix_gcd","title":"<code>matrix_gcd(m1, m2, max_divisor=10000)</code>","text":"<p>Return a greatest common divisor of rational matrices <code>m1</code> and <code>m2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m1</code> <code>(3, 3) array_like</code> <p>Nonsingular rational matrices.</p> required <code>m2</code> <code>(3, 3) array_like</code> <p>Nonsingular rational matrices.</p> required <code>max_divisor</code> <code>int</code> <p>A positive integer. The least common multiple of all divisors in <code>m</code> should not be greater than <code>max_divisor</code>.</p> <code>10000</code> <p>Returns:</p> Name Type Description <code>d</code> <code>(3, 3) array</code> <p>The greatest common divisor of <code>m1</code> and <code>m2</code> in Hermite normal form.</p>"},{"location":"api/#crystmatch.utilities.matrix_lcm","title":"<code>matrix_lcm(m1, m2)</code>","text":"<p>Return a least common multiple of integer matrices <code>m1</code> and <code>m2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m1</code> <code>(3, 3) array_like</code> <p>Nonsingular integer matrices.</p> required <code>m2</code> <code>(3, 3) array_like</code> <p>Nonsingular integer matrices.</p> required <p>Returns:</p> Name Type Description <code>m</code> <code>(3, 3) array</code> <p>The least common multiple of <code>m1</code> and <code>m2</code> in Hermite normal form.</p>"},{"location":"api/#crystmatch.utilities.niggli_cell","title":"<code>niggli_cell(c)</code>","text":"<p>Reduce cell <code>c</code> to its Niggli cell.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array</code> <p>The cell to be reduced, whose columns are cell vectors.</p> required <p>Returns:</p> Name Type Description <code>cc</code> <code>(3, 3) array</code> <p>The Niggli cell, with shortest right-handed cell vectors.</p> <code>q</code> <code>(3, 3) array of ints</code> <p>The unimodular matrix satisfying <code>cc = c @ q</code>.</p>"},{"location":"api/#crystmatch.utilities.rmss","title":"<code>rmss(x)</code>","text":"<p>Root-mean-square strain of given singular values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>(..., 3) array</code> <p>The singular values of 3*3 matrices.</p> required <p>Returns:</p> Name Type Description <code>rms_strain</code> <code>(...) array</code> <p>Root-mean-square of <code>x - 1</code>.</p>"},{"location":"api/#crystmatch.utilities.save_poscar","title":"<code>save_poscar(filename, cryst, crystname=None)</code>","text":"<p>Save the crystal structure to a POSCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save, must not already exist in current directory.</p> required <code>cryst</code> <code>cryst</code> <p>The crystal structure to be saved, consisting of the lattice vectors, species, and positions.</p> required <code>crystname</code> <code>str</code> <p>A system description to write to the comment line of the POSCAR file. If <code>crystname = None</code>, <code>filename</code> will be used.</p> <code>None</code>"},{"location":"api/#crystmatch.utilities.vector_reduce","title":"<code>vector_reduce(v, divisors)</code>","text":"<p>Minimizing the norm of <code>v</code> by adding and subtracting columns of <code>divisors</code>.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>(N,) array</code> <p>The vector to be reduced.</p> required <code>divisors</code> <code>(N, ...) array</code> <p>The vectors used to translate <code>v</code>.</p> required <p>Returns:</p> Name Type Description <code>vv</code> <code>(N,) array</code> <p>The reduced <code>v</code> with minimum Euclidean norm.</p>"}]}