{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tutorial","text":"<p>Abstract</p> <p>A solid-solid phase transition establishes an atom-to-atom correspondence between the initial and final crystal structures \\(\\mathcal A\\) and \\(\\mathcal B\\). Such correspondence is called a crystal-structure match (CSM). A CSM can be described by a pair of POSCAR files, which specifies how the lattice deforms from \\(\\mathcal A\\) to \\(\\mathcal B\\) and the correspondence between atoms in a supercell of \\(\\mathcal A\\) and those in \\(\\mathcal B\\).</p> <p>The main functions of <code>crystmatch</code> are as follows:</p> <ul> <li> <p>Enumeration:</p> <ul> <li>Provide a complete list of representative CSMs between \\(\\mathcal A\\) and \\(\\mathcal B\\), with user-specified upper bounds on the multiplicity and strain.</li> <li>Provide a complete list of CSMs with user-specified upper bounds on the multiplicity, strain, and shuffle distance.</li> </ul> </li> <li> <p>Analysis:</p> <ul> <li>Read a CSM from a pair of POSCAR files, and save CSMs in the same format.</li> <li>Calculate the root-mean-squared strain (RMSS), estimated strain energy density, and shuffle distance (RMSD) for each CSM.</li> <li>Benchmark each CSM by its deviation angle from a given orientation relationship.</li> <li>Visualize the distribution of strain, shuffle distance, and multiplicity of CSMs in a 2D scatter plot.</li> <li>Visualize a CSM in a 3D interactive plot.</li> </ul> </li> </ul> <p>Congruent CSMs (those differ only by a space-group transformation) are identified and excluded from the enumeration using the Spglib library by Atsushi Togo et al.</p>"},{"location":"#installation","title":"Installation","text":"<p>Make sure you have Python 3.9 or later installed. You can check it by running:</p> <pre><code>python3 --version\n</code></pre> <p>To install the latest version of <code>crystmatch</code>, run:</p> <pre><code>pip3 install --upgrade numpy scipy spglib numba matplotlib\npip3 install --upgrade crystmatch\n</code></pre> <p>Check whether <code>crystmatch</code> is successfully installed:</p> <pre><code>crystmatch --version\n</code></pre> <p>Tip</p> <p>If you prefer using <code>conda</code>, you can install <code>crystmatch</code> by running: <pre><code>conda install -c conda-forge crystmatch\n</code></pre> and update it by running: <pre><code>conda update -c conda-forge crystmatch\n</code></pre></p>"},{"location":"#how-to-cite","title":"How to cite","text":"<p>If you use <code>crystmatch</code> in your research, please cite one of the following paper:</p> <ul> <li> <p>Crystal-Structure Matches in Solid-Solid Phase Transitions</p> <p>Physical Review Letters 132, 086101 (2024)</p> <pre><code>@article{wang2024crystal,\n    title={Crystal-Structure Matches in Solid-Solid Phase Transitions},\n    author={Wang, Fang-Cheng and Ye, Qi-Jun and Zhu, Yu-Cheng and Li, Xin-Zheng},\n    journal={Phys. Rev. Lett.},\n    volume={132},\n    number={8},\n    pages={086101},\n    year={2024},\n    publisher={APS},\n    doi={10.1103/PhysRevLett.132.086101}\n}\n</code></pre> </li> <li> <p>Classification and Enumeration of Solid-Solid Phase Transition Mechanisms</p> <p>Under review (2025)</p> <pre><code>@article{wang2025classification,\n    title={Classification and Enumeration of Solid-Solid Phase Transition Mechanisms},\n    author={Wang, Fang-Cheng and Ye, Qi-Jun and Zhu, Yu-Cheng and Li, Xin-Zheng},\n    journal={arXiv:2506.05105},\n    year={2025},\n    doi={10.48550/arXiv.2506.05105}\n}\n</code></pre> </li> </ul>"},{"location":"#usage","title":"Usage","text":"<p>To run <code>crystmatch</code>, one of the following modes must be selected:</p> <ol> <li> <p><code>--enumerate</code></p> <p>Enumerate a list of representative CSMs, save them to a <code>CSMLIST.npz</code> file, and perform preliminary analysis. The initial and final crystal structures must be specified in two separate POSCAR files.</p> </li> <li> <p><code>--read</code></p> <p>Read CSMs from a <code>CSMLIST.npz</code> file. You can export specific CSMs to POSCARs or XDATCARs, perform orientation-relationship analysis, and visualize them interactively.</p> </li> <li> <p><code>--direct</code></p> <p>Directly determine a single CSM by two POSCAR files (must have the same number of atoms) and perform detailed analysis.</p> </li> </ol> <p>We strongly recommend starting with the examples provided below, and then see all available options. To see the help message, run:</p> <pre><code>crystmatch --help\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#enumerating-representative-csms","title":"Enumerating representative CSMs","text":"<p>To enumerate a list of representative CSMs (each representing a unique deformation) between two crystal structures given by POSCAR files <code>Graphite</code> and <code>Diamond</code>, with upper bounds <code>MAX_MU = 2</code> for multiplicity and <code>MAX_STRAIN = 0.4</code> for RMSS, run:</p> <pre><code>crystmatch --enumerate Graphite Diamond 2 0.4\n</code></pre> <p>Caveat</p> <p>We recommend you to try <code>MAX_MU = 2</code> and <code>MAX_STRAIN = 0.4</code> first, and then gradually adjust these upper bounds, usually by increasing <code>MAX_MU</code> and decreasing <code>MAX_STRAIN</code>, to obtain desired results. Otherwise, the enumeration may take a very long time, or find no CSMs at all.</p> <p>Suggestion</p> <p>If you are using a job scheduling system such as SLURM on a remote server, you can redirect the output of <code>crystmatch</code> to a log file and monitor the progress in real time using:</p> <pre><code>crystmatch --enumerate Graphite Diamond 2 0.4 &gt; log\n</code></pre> <p>The following files will be created in the current directory:</p> <pre><code>./\n\u251c\u2500\u2500 CSMLIST-m2s0.4.npz       # stores the enumerated CSMs and metadata\n\u251c\u2500\u2500 SUMMARY-m2s0.4.csv       # lists the multiplicity, RMSS, and RMSD\n\u2514\u2500\u2500 SCATTER-m2s0.4.pdf       # shows the RMSD-RMSS distribution of the CSMs\n</code></pre> <p>Here, <code>CSMLIST-m2s0.4.npz</code> contains all information of the enumerated CSMs and SLMs, but is not intended to be human-readable. <code>SUMMARY-m2s0.4.csv</code> look like this:</p> <pre><code># ./SUMMARY-m2s0.4.csv\n\n# csm_id,  slm_id,      mu,  period,  rmss/%,  rmsd/\u212b\n       0,       0,       1,       4,   21.28,  0.4788\n       1,       1,       1,       4,   26.20,  0.6833\n       2,       2,       1,       4,   30.47,  0.4884\n       3,       3,       1,       4,   36.85,  0.7826\n       4,       4,       1,       4,   37.89,  0.5036\n       5,       5,       1,       4,   39.79,  0.7856\n       6,       6,       2,       8,   14.34,  0.9107\n       7,       7,       2,       8,   19.50,  0.8152\n</code></pre> <p><code>SCATTER-m2s0.4.pdf</code> visualizes the RMSD-RMSS-multiplicity distribution of the CSMs.</p>"},{"location":"#enumerating-all-csms","title":"Enumerating all CSMs","text":"<p>To enumerate all CSMs (representative and nonrepresentative) between two crystal structures given by POSCAR files <code>Graphite</code> and <code>Diamond</code>, with upper bounds <code>MAX_MU = 2</code> for multiplicity, <code>MAX_STRAIN = 0.4</code> for RMSS, and <code>MAX_D = 1.8</code> for RMSD, run:</p> <pre><code>crystmatch --enumerate Graphite Diamond 2 0.4 --all 1.8\n</code></pre> <p>The following files will be created in the current directory:</p> <pre><code>./\n\u251c\u2500\u2500 CSMLIST-m2s0.4d1.8.npz     # stores the enumerated CSMs and metadata\n\u251c\u2500\u2500 SUMMARY-m2s0.4d1.8.csv     # lists the multiplicity, RMSS, and RMSD\n\u2514\u2500\u2500 SCATTER-m2s0.4d1.8.pdf     # shows the RMSD-RMSS distribution of the CSMs\n</code></pre> <p>Caveat</p> <p>Using <code>--all MAX_D</code> with large <code>MAX_MU</code> may result in a very large number of CSMs. We recommend you to try <code>MAX_D = 1.2</code> first, and then gradually increase it to obtain desired results.</p> <p>If you wish to apply weighting to atomic species when calculating RMSD, prepare a CSMCAR file and use the <code>--extra</code> option. See CSMCAR for details.</p>"},{"location":"#visualizing-csms-in-a-3d-interactive-plot","title":"Visualizing CSMs in a 3D interactive plot","text":"<p>If you are using <code>crystmatch</code> in a local terminal, you can visualize the CSMs in a 3D interactive plot by adding the <code>--interact</code> option, as shown below. You can rotate and zoom the plot using your mouse or touchpad.</p> <p></p> <p>However, using <code>--interact</code> in <code>--enumerate</code> mode might be unwise, as you would have to visually inspect numerous CSMs one by one. The recommended workflow is:</p> <ol> <li>Perform enumeration (using <code>--all MAX_D</code> or not), generating <code>SCATTER.pdf</code>, <code>SUMMARY.csv</code>, and <code>CSMLIST.npz</code>.</li> <li>See <code>SCATTER.pdf</code> and roughly note the RMSS and RMSD values of CSMs of interest.</li> <li>Identify the corresponding <code>csm_id</code> values for these CSMs in <code>SUMMARY.csv</code>, e.g., <code>1</code>, <code>14</code>, <code>514</code>.</li> <li> <p>Read these CSMs from <code>CSMLIST.npz</code> using <code>--read CSMLIST [IND1 IND2 ...]</code>, e.g., run:</p> <pre><code>crystmatch --read CSMLIST.npz 1 14 514 --interact\n</code></pre> </li> </ol> <p>Suggestion</p> <p>You can enumerate CSMs on a remote server or WSL, and then download the <code>CSMLIST.npz</code> file to your local machine so that the CSMs can be visualized interactively using <code>--interact</code>.</p>"},{"location":"#exporting-csms-as-poscar-or-xdatcar-files","title":"Exporting CSMs as POSCAR or XDATCAR files","text":"<p>To export CSMs with <code>csm_id</code> values <code>7</code> and <code>10</code> from <code>CSMLIST.npz</code> as POSCAR files, run:</p> <pre><code>crystmatch --read CSMLIST.npz 7 10 --poscar\n</code></pre> <p>Two folders will be created in <code>./EXPORT-read/</code>, each containing a pair of POSCAR files representing the CSM:</p> <pre><code>./EXPORT-read/\n\u251c\u2500\u2500 CSM_7/\n\u2502   \u251c\u2500\u2500 POSCAR_I\n\u2502   \u2514\u2500\u2500 POSCAR_F\n\u2514\u2500\u2500 CSM_10/\n    \u251c\u2500\u2500 POSCAR_I\n    \u2514\u2500\u2500 POSCAR_F\n</code></pre> <p>You can also export CSMs as XDATCAR files using the <code>--xdatcar</code> option. Both <code>--poscar</code> and <code>--xdatcar</code> are also available in <code>--enumerate</code> and <code>--direct</code> modes.</p>"},{"location":"#identifying-csm-from-a-pair-of-poscar-files","title":"Identifying CSM from a pair of POSCAR files","text":"<p>To identify and analyze the CSM defined by a pair of POSCAR files <code>POSCAR_I</code> and <code>POSCAR_F</code>, run:</p> <pre><code>crystmatch --direct POSCAR_I POSCAR_F\n</code></pre> <p>To enumerate all CSMs with identical initial and final supercells as <code>POSCAR_I</code> and <code>POSCAR_F</code>, but different atomic correspondences, run:</p> <pre><code>crystmatch --direct POSCAR_I POSCAR_F --all MAX_D\n</code></pre> <p>Here, <code>MAX_D</code> should be set to a smaller value if the supercells contain many atoms.</p>"},{"location":"#orientation-relationship-analysis","title":"Orientation-relationship analysis","text":"<p>In <code>--enumerate</code>, <code>--read</code>, and even <code>--direct</code> modes, you can perform orientation-relationship analysis by using <code>--orientation ASSUM</code> and <code>--extra CSMCAR</code>. See CSMCAR for details.</p>"},{"location":"#computing-estimated-strain-energy-density","title":"Computing estimated strain energy density","text":"<p>If you want to use the estimated strain energy density, rather than the RMSS, to quantify the strain, you should provide the elastic tensors of the initial and final structures in the CSMCAR file.</p>"},{"location":"about/","title":"About","text":"<p>Crystmatch is developed by the Xin-Zheng Li (\u674e\u65b0\u5f81) Group at the School of Physics, Peking University. Our research focuses on computer simulations of material properties, covering a wide range of first-principles methods in condensed matter physics and theoretical chemistry, as well as some fundamental theories in statistical physics. These methods and theories include, for example:</p> <ul> <li> <p>Path-integral methods for the description of statistical nuclear quantum effects (closed-path and open-path; distinguishable particles and bosonic or fermionic systems),</p> </li> <li> <p>The instanton method for quantum tunneling,</p> </li> <li> <p>The initial value representation method for quantum dynamics,</p> </li> <li> <p>Crystal structure matching for solid-solid phase transitions,</p> </li> <li> <p>Non-equilibrium Green's function theory for quantum friction and quantum dragging, and</p> </li> <li> <p>The Yang-Lee theory for phase transitions.</p> </li> </ul> <p>In addition to our research group, we would like to express our gratitude to:</p> <ul> <li> <p>Dr. F\u00e9lix Therrien, for his pioneering work and guidance on orientation analysis;</p> </li> <li> <p>Yi-Chi Zhang (\u5f20\u4ea6\u5f1b), for his crucial feedback on shuffle distance calculations;</p> </li> <li> <p>Wuji Han (\u97e9\u65e0\u6781) and Zhilin Chang (\u5e38\u7a1a\u6797), for their contributions to parallelization.</p> </li> </ul> <p>You are welcome to contact us at <code>wfc@pku.edu.cn</code> for any questions, feedback or comments regarding <code>crystmatch</code>.</p>"},{"location":"api/","title":"Python API","text":"<p>In progress</p> <p>The API reference for <code>crystmatch</code> v2.0.0 is still under development. Please do not rely on it yet.</p> Data type Structure Description <code>cryst</code> <code>(lattice, species, positions)</code> A crystal structure described by a primitive cell <code>lattice</code>, atomic species <code>species</code>, and fractional coordinates <code>positions</code>. Cell vectors are rows of <code>lattice</code>. <code>slm</code> <code>(hA, hB, q)</code> A sublattice match (SLM) described by an integer-matrix triplet."},{"location":"api/#crystmatch","title":"<code>crystmatch</code>","text":"<p>Enumerating and analyzing crystal-structure matches.</p>"},{"location":"api/#crystmatch.load_poscar","title":"<code>load_poscar(filename, to_primitive=True, tol=0.001, verbose=True)</code>","text":"<p>Load the crystal structure from a POSCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the POSCAR file to be read.</p> required <code>to_primitive</code> <code>bool</code> <p>Using the primitive cell instead of the cell given by the POSCAR file. Default is True.</p> <code>True</code> <code>tol</code> <code>float</code> <p>The tolerance for <code>spglib</code> symmetry detection. Default is 1e-3.</p> <code>0.001</code> <p>Returns:</p> Name Type Description <code>cryst</code> <code>cryst</code> <p>The loaded crystal structure, consisting of the lattice vectors, species, and positions.</p>"},{"location":"api/#crystmatch.load_csmcar","title":"<code>load_csmcar(filename, verbose=True)</code>","text":"<p>Load the CSMCAR file, which contains <code>crystmatch</code> parameters.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the POSCAR file to be read.</p> required <p>Returns:</p> Name Type Description <code>voigtA, voigtB : (6, 6) array</code> <p>The loaded elastic tensor for the initial and final structure, in Voigt notation (ordered as XX, YY, ZZ, YZ, ZX, XY).</p> <code>weight_func</code> <code>dict</code> <p>The loaded weight function for the shuffle distance.</p> <code>ori_rel</code> <code>(2, 2, 3) array</code> <p>The two loaded parallelisms, representing the orientation relationship between the initial and final structure.</p>"},{"location":"api/#crystmatch.primitive_cryst","title":"<code>primitive_cryst(cryst_sup, tol=0.001)</code>","text":""},{"location":"api/#crystmatch.check_stoichiometry","title":"<code>check_stoichiometry(speciesA, speciesB)</code>","text":""},{"location":"api/#crystmatch.create_common_supercell","title":"<code>create_common_supercell(crystA, crystB, slm)</code>","text":"<p>Return the initial, final, and half-distorted supercell, as well as the transformation matrices.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slm</code> <code>slm</code> <p>The SLM of the CSM.</p> required <p>Returns:</p> Name Type Description <code>crystA_sup</code> <code>cryst</code> <p>The supercell structure of <code>crystA</code>.</p> <code>crystB_sup</code> <code>cryst</code> <p>The supercell structure of <code>crystB</code>.</p> <code>c_sup_half</code> <code>(3, 3) array of floats</code> <p>The half-distorted supercell.</p> <code>mA, mB : (3, 3) array of ints</code> <p>The matrices that transform <code>crystA</code> to <code>crystA_sup</code> and <code>crystB</code> to <code>crystB_sup</code>, respectively.</p>"},{"location":"api/#crystmatch.frac_cell","title":"<code>frac_cell(mA, mB)</code>","text":"<p>The primitive cell of the lattice generated by mA^{-1} and mB^{-1}.</p>"},{"location":"api/#crystmatch.imt_multiplicity","title":"<code>imt_multiplicity(crystA, crystB, slmlist)</code>","text":"<p>Return multiplicities of elements in <code>slmlist</code>.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>crystB</code> <code>cryst</code> <p>The final crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>slmlist</code> <code>list of slm</code> <p>A list of SLMs, each represented by a triplet of integer matrices like <code>(hA, hB, q)</code>.</p> required <p>Returns:</p> Name Type Description <code>mu</code> <code>int or (...,) array of ints</code> <p>Multiplicities of each SLM in <code>slmlist</code>.</p>"},{"location":"api/#crystmatch.deformation_gradient","title":"<code>deformation_gradient(crystA, crystB, slmlist)</code>","text":"<p>Compute the deformation gradient matrices of given IMTs.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slmlist</code> <code>list of slm</code> <p>The IMTs.</p> required <p>Returns:</p> Name Type Description <code>slist</code> <code>(..., 3, 3) array</code> <p>A list of deformation gradient matrices.</p>"},{"location":"api/#crystmatch.rmss","title":"<code>rmss(slist)</code>","text":"<p>Root-mean-square strains of given deformation gradient matrices.</p> <p>Parameters:</p> Name Type Description Default <code>slist</code> <code>(..., 3, 3) array</code> <p>A list of deformation gradient matrices.</p> required <p>Returns:</p> Name Type Description <code>rmss</code> <code>(...) array</code> <p>Root-mean-square strains.</p>"},{"location":"api/#crystmatch.get_pure_rotation","title":"<code>get_pure_rotation(cryst, tol=0.001)</code>","text":"<p>Find all pure rotations appeared in the space group of <code>cryst</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cryst</code> <code>3 - tuple</code> <p><code>(lattice, species, positions)</code>, representing the crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>tol</code> <code>float</code> <p>The tolerance for <code>spglib</code> symmetry detection. Default is 1e-3.</p> <code>0.001</code> <p>Returns:</p> Name Type Description <code>g</code> <code>(..., 3, 3) array of ints</code> <p>A point group of the first kind, containing all pure rotations appeared in the space group of <code>cryst</code>,             elements of which are integer matrices (under fractional coordinates).</p>"},{"location":"api/#crystmatch.int_vec_inside","title":"<code>int_vec_inside(c)</code>","text":"<p>Integer vectors inside the cell <code>c @ [0, 1)^3</code> whose elements are integers.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array of ints</code> <p>A matrix whose columns are integer cell vectors.</p> required <p>Returns:</p> Name Type Description <code>v_int</code> <code>(3, ...) array of ints</code> <p>Its columns are vectors satisfying <code>v = c @ k</code>, where <code>k[0]</code>, <code>k[1]</code>, <code>k[2]</code> are all in <code>[0, 1)</code>.</p>"},{"location":"api/#crystmatch.all_hnfs","title":"<code>all_hnfs(det)</code>","text":"<p>Enumerate all 3*3 column Hermite normal forms (HNFs) with given determinant.</p> <p>Parameters:</p> Name Type Description Default <code>det</code> <code>int</code> <p>The determinant of HNFs.</p> required <p>Returns:</p> Name Type Description <code>l</code> <code>(..., 3, 3) array of ints</code> <p>Contains all HNFs with determinant <code>det</code>.</p>"},{"location":"api/#crystmatch.hnf","title":"<code>hnf(m, return_q=False)</code>","text":"<p>Compute the Hermite normal form of integer matrix <code>m</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>(M, N) array of ints</code> <p>The integer matrix to decompose, with positive determinant and M &lt;= N.</p> required <code>return_q</code> <code>bool</code> <p>Whether to return the unimodular matrix <code>q</code>. Default is True.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>h</code> <code>(M, N) array of ints</code> <p>The column-style Hermite normal form of <code>m</code>.</p> <code>q</code> <code>(N, N) array of ints</code> <p>The unimodular matrix satisfying <code>m</code> = <code>h @ q</code>.</p>"},{"location":"api/#crystmatch.lll_reduce","title":"<code>lll_reduce(c, delta=0.75)</code>","text":"<p>Return the LLL-reduced cell <code>cc</code> and the unimodular matrix <code>q</code> such that <code>cc = c @ q</code></p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array</code> <p>The cell to be reduced, whose columns are cell vectors.</p> required <code>delta</code> <code>float</code> <p>The parameter for the LLL algorithm. Default is 0.75.</p> <code>0.75</code> <p>Returns:</p> Name Type Description <code>cc</code> <code>(3, 3) array</code> <p>The LLL-reduced cell.</p> <code>q</code> <code>(3, 3) array of ints</code> <p>The unimodular matrix satisfying <code>cc = c @ q</code>.</p>"},{"location":"api/#crystmatch.voigt_to_tensor","title":"<code>voigt_to_tensor(voigt_matrix, cryst=None, tol=0.001, verbose=True)</code>","text":"<p>Convert a Voigt-notation tensor to a rank-4 tensor, and symmetrize it according to the symmetry of <code>cryst</code> (if provided).</p> <p>Parameters:</p> Name Type Description Default <code>voigt_matrix</code> <code>(6, 6) array</code> <p>The elastic tensor, in Voigt notation (ordered as XX, YY, ZZ, YZ, ZX, XY).</p> required <code>cryst</code> <code>Cryst</code> <p>The crystal structure, whose symmetry is used to symmetrize the elastic tensor.</p> <code>None</code> <code>tol</code> <code>float</code> <p>The tolerance for symmetry finding.</p> <code>0.001</code> <code>verbose</code> <code>bool</code> <p>Whether to print information about the symmetrization.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>tensor</code> <code>(3, 3, 3, 3) array</code> <p>The rank-4 elastic tensor.</p>"},{"location":"api/#crystmatch.pct_distance","title":"<code>pct_distance(c, pA, pB, p, ks, weights=None, l=2, min_t0=True, return_t0=False)</code>","text":"<p>Return the shuffle distance of a PCT.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array</code> <p>The lattice vectors of the crystal structure.</p> required <code>pA</code> <code>(3, Z) array</code> <p>The fractional coordinates of the atoms in the initial and final structures, respectively.</p> required <code>pB</code> <code>(3, Z) array</code> <p>The fractional coordinates of the atoms in the initial and final structures, respectively.</p> required <code>p</code> <code>(Z, ) array of ints</code> <p>The permutation of the atoms.</p> required <code>ks</code> <code>(3, Z) array of floats</code> <p>The class-wise translations (fractional coordinates) of the atoms in <code>pB</code>.</p> required <code>weights</code> <code>(Z, ) array of floats</code> <p>The weights of each atom. Default is None, which means all atoms have the same weight.</p> <code>None</code> <code>l</code> <code>float</code> <p>The l-norm to be used for distance calculation, must not be less than 1. Default is 2.</p> <code>2</code> <code>min_t0</code> <code>bool</code> <p>Set to True to minimize the shuffle distance by translating the final structure. Default is True.</p> <code>True</code> <code>return_t0</code> <code>bool</code> <p>Whether to return the best overall translation if <code>min_t0</code> is True. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>distance</code> <code>float</code> <p>The shuffle distance.</p> <code>t0</code> <code>(3, 1) array</code> <p>The best overall translation, reshaped as a 3x1 matrix.</p>"},{"location":"api/#crystmatch.standardize_imt","title":"<code>standardize_imt(slm, gA, gB)</code>","text":"<p>The standard SLM of the congruence class of <code>slm</code>.</p> <p>Parameters:</p> Name Type Description Default <code>slm</code> <code>slm</code> <p><code>(hA, hB, q)</code>, representing a SLM.</p> required <code>gA</code> <code>(..., 3, 3) array of ints</code> <p>The rotation group of the initial crystal structure, whose elements are             integer matrices under fractional coordinates.</p> required <code>gB</code> <code>(..., 3, 3) array of ints</code> <p>The rotation group of the final crystal structure, whose elements are             integer matrices under fractional coordinates.</p> required <p>Returns:</p> Name Type Description <code>slm0</code> <code>slm</code> <p>The standardized SLM.</p>"},{"location":"api/#crystmatch.strain_energy_func","title":"<code>strain_energy_func(elasticA, elasticB)</code>","text":"<p>Return the strain energy density function.</p>"},{"location":"api/#crystmatch.enumerate_imt","title":"<code>enumerate_imt(crystA, crystB, mu, max_strain, strain=rmss, tol=0.001, max_iter=1000, verbose=1)</code>","text":"<p>Enumerating all IMTs of multiplicity <code>mu</code> with <code>strain</code> smaller than <code>max_strain</code>.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>Cryst</code> <p>The initial crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>crystB</code> <code>Cryst</code> <p>The final crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>mu</code> <code>int</code> <p>The multiplicity of SLMs to enumerate.</p> required <code>max_strain</code> <code>float</code> <p>The maximum strain energy density, with the same units as <code>strain</code>.</p> required <code>strain</code> <code>Callable</code> <p>How to quantify the strain, usually <code>rmss</code> or obtained via <code>strain_energy_func()</code>. Default is <code>rmss</code>.</p> <code>rmss</code> <code>tol</code> <code>float</code> <p>The tolerance for determining the pure rotation group of the crystal structures. Default is 1e-3.</p> <code>0.001</code> <code>max_iter</code> <code>int</code> <p>The maximum number of consequtive iterations without finding any new SLMs. Default is 100.</p> <code>1000</code> <code>verbose</code> <code>int</code> <p>The level of verbosity. Default is 1.</p> <code>1</code>"},{"location":"api/#crystmatch.optimize_pct","title":"<code>optimize_pct(crystA, crystB, slm, constraint=Constraint(set(), set()), weight_func=None, l=2, t_grid=64)</code>","text":""},{"location":"api/#crystmatch.pct_fill","title":"<code>pct_fill(crystA, crystB, slm, max_d, p, ks0=None, weight_func=None, l=2, warning_threshold=5000)</code>","text":"<p>Returns all class-wise translations with permutation p that has d &lt;= max_d, including ks0.</p>"},{"location":"api/#crystmatch.murty_split","title":"<code>murty_split(node, p)</code>","text":""},{"location":"api/#crystmatch.cong_permutations","title":"<code>cong_permutations(p, crystA, crystB, slm)</code>","text":""},{"location":"api/#crystmatch.enumerate_pct","title":"<code>enumerate_pct(crystA, crystB, slm, max_d, weight_func=None, l=2, t_grid=16, incong=True, verbose=1, warning_threshold=5000)</code>","text":""},{"location":"api/#crystmatch.optimize_ct","title":"<code>optimize_ct(crystA, crystB, slm, p, weight_func=None, l=2, t_grid=64)</code>","text":""},{"location":"api/#crystmatch.enumerate_rep_csm","title":"<code>enumerate_rep_csm(crystA, crystB, max_mu, max_strain, strain=rmss, tol=0.001, max_iter=1000, weight_func=None, l=2, t_grid=64, verbose=1)</code>","text":"<p>Enumerating all representative CSMs with multiplicity and strain not larger than <code>max_mu</code> and <code>max_strain</code>.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>Cryst</code> <p>The initial crystal structure.</p> required <code>crystB</code> <code>Cryst</code> <p>The final crystal structure.</p> required <code>max_mu</code> <code>int</code> <p>The maximum multiplicity of the IMTs to be enumerated.</p> required <code>max_strain</code> <code>float</code> <p>The maximum value of the function <code>strain</code>.</p> required <code>strain</code> <code>Callable</code> <p>How to quantify the strain, usually <code>rmss</code> or obtained via <code>strain_energy_func()</code>. Default is <code>rmss</code>.</p> <code>rmss</code> <code>tol</code> <code>float</code> <p>The tolerance for <code>spglib</code> symmetry detection. Default is 1e-3.</p> <code>0.001</code> <code>max_iter</code> <code>int</code> <p>The maximum iteration number for IMT generation. Default is 1000.</p> <code>1000</code> <code>weight_func</code> <code>dict</code> <p>A dictionary of atomic weights for each species. Default is None, which means all atoms have the same weight.</p> <code>None</code> <code>l</code> <code>float</code> <p>The type of norm to be used for distance calculation. Default is 2.</p> <code>2</code> <code>t_grid</code> <code>int</code> <p>The number of grid points for PCT optimization. Default is 64.</p> <code>64</code> <code>verbose</code> <code>int</code> <p>The level of verbosity. Default is 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>slmlist</code> <code>(N, 3, 3, 3) array of ints</code> <p>The IMTs enumerated.</p> <code>pct_arrs</code> <code>list of (..., 4) arrays of ints</code> <p>The PCTs of representative CSMs, where <code>...</code> is the number of CSMs with multiplicity <code>mu</code>.</p> <code>mulist</code> <code>(N,) array of ints</code> <p>The multiplicities of the representative CSMs.</p> <code>strainlist</code> <code>(N,) array of floats</code> <p>The <code>strain</code> values of the representative CSMs.</p> <code>d0list</code> <code>(N, ) array of floats</code> <p>The shuffle distances of the representative CSMs.</p>"},{"location":"api/#crystmatch.enumerate_all_csm","title":"<code>enumerate_all_csm(crystA, crystB, max_mu, max_strain, max_d, strain=rmss, tol=0.001, max_iter=1000, weight_func=None, l=2, t_grid=16, verbose=1)</code>","text":"<p>Enumerating all CSMs with multiplicity, strain, and shuffle distance not larger than <code>max_mu</code>, <code>max_strain</code>, and <code>max_d</code>.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>Cryst</code> <p>The initial crystal structure.</p> required <code>crystB</code> <code>Cryst</code> <p>The final crystal structure.</p> required <code>max_mu</code> <code>int</code> <p>The maximum multiplicity.</p> required <code>max_strain</code> <code>float</code> <p>The maximum value of the function <code>strain</code>.</p> required <code>max_d</code> <code>float</code> <p>The maximum shuffle distance.</p> required <code>strain</code> <code>Callable</code> <p>How to quantify the strain, usually <code>rmss</code> or obtained via <code>strain_energy_func()</code>. Default is <code>rmss</code>.</p> <code>rmss</code> <code>tol</code> <code>float</code> <p>The tolerance for <code>spglib</code> symmetry detection. Default is 1e-3.</p> <code>0.001</code> <code>max_iter</code> <code>int</code> <p>The maximum iteration number for IMT generation. Default is 1000.</p> <code>1000</code> <code>weight_func</code> <code>dict</code> <p>A dictionary of atomic weights for each species. Default is None, which means all atoms have the same weight.</p> <code>None</code> <code>l</code> <code>float</code> <p>The type of norm to be used for distance calculation. Default is 2.</p> <code>2</code> <code>t_grid</code> <code>int</code> <p>The number of grid points for PCT optimization. Default is 16.</p> <code>16</code> <code>verbose</code> <code>int</code> <p>The level of verbosity. Default is 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>slmlist</code> <code>(N, 3, 3, 3) array of ints</code> <p>The IMTs enumerated.</p> <code>slm_ind</code> <code>(N,) array of ints</code> <p>The indices of the IMTs of the CSMs.</p> <code>pct_arrs</code> <code>list of (..., 4) arrays of ints</code> <p>The PCTs of the CSMs, where <code>...</code> is the number of CSMs with multiplicity <code>mu</code>.</p> <code>mulist</code> <code>(N,) array of ints</code> <p>The multiplicities of the CSMs.</p> <code>strainlist</code> <code>(N,) array of floats</code> <p>The <code>strain</code> values of the CSMs.</p> <code>dlist</code> <code>(N, ) array of floats</code> <p>The shuffle distances of the CSMs.</p>"},{"location":"api/#crystmatch.conventional_cryst","title":"<code>conventional_cryst(cryst_sup, return_primitive=False, tol=0.001)</code>","text":"<p>Rotate the crystal structure and change its lattice basis to make it conventional.</p>"},{"location":"api/#crystmatch.decompose_cryst","title":"<code>decompose_cryst(cryst_sup, cryst_prim=None, tol=0.001)</code>","text":"<p>Compute the rotation <code>r</code> and the integer transformation matrix <code>m</code> such that <code>c_sup = r @ c_prim @ m</code></p>"},{"location":"api/#crystmatch.csm_to_cryst","title":"<code>csm_to_cryst(crystA, crystB, slm, p, ks, tol=0.001, orientation='norot', min_t0=False, weight_func=None, l=2)</code>","text":"<p>Convert the IMT and PCT representation of a CSM to a pair of crysts.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slm</code> <code>slm</code> <p>The SLM of the CSM.</p> required <code>p</code> <code>(Z, ) array of ints</code> <p>The permutaion of the shuffle.</p> required <code>ks</code> <code>(3, Z) array of ints</code> <p>The lattice-vector translations of the shuffle.</p> required <code>tol</code> <code>float</code> <p>The tolerance for symmetry finding. Default is 1e-3.</p> <code>0.001</code> <code>orientation</code> <code>str</code> <p>The orientation of the final structure, either 'norot' or 'uspfixed', which means that the deformation is rotation-free             or fixing the uniformly scaled plane (USP). When 'uspfixed', two final structures are returned since there are two USPs.             Default is 'norot'.</p> <code>'norot'</code> <code>min_t0</code> <code>bool</code> <p>Whether to use optimal translation of <code>crystB_sup_norot</code> to minimize the shuffle distance. Default is False.</p> <code>False</code> <code>weight_func</code> <code>dict</code> <p>The weight function used when minimizing the shuffle distance, with keys as atomic species.             Default is None, which means all atoms have the same weight.</p> <code>None</code> <code>l</code> <code>float</code> <p>The l-norm to be used for distance calculation, must not be less than 1. Default is 2.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>crystA_sup</code> <code>cryst</code> <p>The initial structure.</p> <code>crystB_sup_norot</code> <code>cryst</code> <p>The final structure, whose lattice vectors and atoms are matched to <code>crystA_sup</code> according to the CSM, with rotation-free orientation.</p> <code>crystB_sup_uspfixed_1, crystB_sup_uspfixed_2 : cryst</code> <p>The final structure, whose lattice vectors and atoms are matched to <code>crystA_sup</code> according to the CSM, with uniformly scaled plane fixed.</p>"},{"location":"api/#crystmatch.cryst_to_csm","title":"<code>cryst_to_csm(crystA_sup, crystB_sup, tol=0.001)</code>","text":"<p>Return the primitive crysts and IMT and PCT representation of a CSM determined by a pair of crysts.</p>"},{"location":"api/#crystmatch.csm_distance","title":"<code>csm_distance(crystA, crystB, slm, p, ks, weight_func=None, l=2, min_t0=True, return_t0=False)</code>","text":"<p>Return the shuffle distance of a CSM.</p>"},{"location":"api/#crystmatch.primitive_shuffle","title":"<code>primitive_shuffle(crystA, crystB, slm0, p0, ks0)</code>","text":"<p>Identify the primitive (with minimal multiplicity) IMT and PCT representations of a CSM.</p>"},{"location":"api/#crystmatch.orient_matrix","title":"<code>orient_matrix(vi, vf, wi, wf)</code>","text":"<p>Rotation matrix <code>r</code> such that <code>r @ vi</code> || <code>vf</code> and <code>r @ wi</code> || <code>wf</code>.</p> <p>Parameters:</p> Name Type Description Default <code>vi</code> <code>(3,) array_like</code> <p>Vectors (cartesian coordinates) that satisfy <code>r @ vi</code> || <code>vf</code>.</p> required <code>vf</code> <code>(3,) array_like</code> <p>Vectors (cartesian coordinates) that satisfy <code>r @ vi</code> || <code>vf</code>.</p> required <code>wi</code> <code>(3,) array_like</code> <p>Vectors (cartesian coordinates) that satisfy <code>r @ wi</code> || <code>wf</code>.</p> required <code>wf</code> <code>(3,) array_like</code> <p>Vectors (cartesian coordinates) that satisfy <code>r @ wi</code> || <code>wf</code>.</p> required <p>Returns:</p> Name Type Description <code>r</code> <code>(3, 3) array</code> <p>A rotation matrix representing the given orientation relationship.</p>"},{"location":"api/#crystmatch.rot_usp","title":"<code>rot_usp(s)</code>","text":"<p>The rotation that the uniformly scaled plane undergoes.</p>"},{"location":"api/#crystmatch.miller_to_vec","title":"<code>miller_to_vec(cryst, hkl, tol=0.001)</code>","text":"<p>Convert Miller indices to cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>cryst</code> <code>cryst</code> <p>The crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>hkl</code> <code>(3,) array_like</code> <p>Miller indices.</p> required <code>tol</code> <code>float</code> <p>Tolerance for determining the symmetry of the crystal. Default is 1e-3.</p> <code>0.001</code> <p>Returns:</p> Name Type Description <code>vec</code> <code>(3,) array</code> <p>Cartesian coordinates of the Miller index.</p>"},{"location":"api/#crystmatch.deviation_angle","title":"<code>deviation_angle(crystA, crystB, slmlist, r, orientation)</code>","text":"<p>Calculate how much each SLM in <code>slmlist</code> differ from a given orientation relationship.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>crystB</code> <code>cryst</code> <p>The final crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>slmlist</code> <code>(N, 3, 3, 3) array of ints</code> <p>A list of SLMs, each represented by a triplet of integer matrices like <code>(hA, hB, q)</code>.</p> required <code>r</code> <code>(3, 3) array</code> <p>A rotation matrix representing the given orientation relationship.</p> required <code>orientation</code> <code>str</code> <p>The orientation of the final structure, either 'norot' or 'uspfixed', which means that the deformation is rotation-free             or fixing the uniformly scaled plane (USP). Default is 'norot'. When 'uspfixed', two final structures are returned since there are two USPs.</p> required <p>Returns:</p> Name Type Description <code>anglelist</code> <code>(N,) array</code> <p>Contains rotation angles that measure the difference of each SLM and the given orientation.</p>"},{"location":"api/#crystmatch.visualize_slmlist","title":"<code>visualize_slmlist(filename, strainlist, dlist, colorlist=None, cmap=plt.get_cmap('viridis'), cbarlabel=None)</code>","text":"<p>Scatter plot of the CSMs with colorbar.</p>"},{"location":"api/#crystmatch.visualize_csm","title":"<code>visualize_csm(crystA, crystB, slm, p, ks, weight_func=None, l=2, tol=0.001, cluster_size=1.2, show_conventional=True, label=None)</code>","text":"<p>Use with <code>%matplotlib widget</code> in Jupyter notebook (need to install <code>ipympl</code>) to interactively visualize the shuffling process.</p>"},{"location":"api/#crystmatch.save_poscar","title":"<code>save_poscar(filename, cryst, crystname=None)</code>","text":"<p>Save the crystal structure to a POSCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save, must not already exist in current directory. If <code>filename = None</code>, a string will be returned instead.</p> required <code>cryst</code> <code>cryst</code> <p>The crystal structure to be saved, consisting of the lattice vectors, species, and positions.</p> required <code>crystname</code> <code>str</code> <p>A system description to write to the comment line of the POSCAR file. If <code>crystname = None</code>, <code>filename</code> will be used.</p> <code>None</code>"},{"location":"api/#crystmatch.save_xdatcar","title":"<code>save_xdatcar(filename, crystA_sup, crystB_sup, images=10, crystname=None)</code>","text":"<p>Save the linear interpolation between <code>crystA</code> and <code>crystB</code> to a single XDATCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save, must not already exist in current directory.</p> required <code>crystA_sup</code> <code>cryst</code> <p>The initial and final crystal structures with specified atomic correspondence, usually obtained by <code>minimize_rmsd</code>.</p> required <code>crystB_sup</code> <code>cryst</code> <p>The initial and final crystal structures with specified atomic correspondence, usually obtained by <code>minimize_rmsd</code>.</p> required <code>images</code> <code>int</code> <p>Number of images to generate. Default is 10.</p> <code>10</code> <code>crystname</code> <code>str</code> <p>A system description to write to the comment line of the POSCAR file. If <code>crystname = None</code>, <code>filename</code> will be used.</p> <code>None</code>"},{"location":"cli/","title":"Command-line interface","text":""},{"location":"cli/#flowchart","title":"Flowchart","text":"<pre><code>flowchart TB\n  config[/\"if &lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; font-family: monospace; word-break: break-word;'&gt;--extra&lt;/code&gt;,&lt;br&gt;read **CSMCAR** file\"/] --&gt; mode;\n  mode{how to&lt;br&gt;**get CSMs**} --&gt; |\"&lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; font-family: monospace; word-break: break-word;'&gt;--enumerate&lt;/code&gt;\"| modeE[enumerate a list of&lt;br&gt;**representative** CSMs];\n  modeE --&gt; all;\n  mode --&gt; |\"&lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; font-family: monospace; word-break: break-word;'&gt;--read&lt;/code&gt;\"| modeR[\"read a list of CSMs&lt;br&gt;from an **NPZ** file&lt;br&gt;\"];\n  modeR --&gt; all;\n  mode --&gt; |\"&lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; font-family: monospace; word-break: break-word;'&gt;--direct&lt;/code&gt;\"| modeD[\"read a single CSM from&lt;br&gt;a pair of **POSCAR** files\"];\n  modeD --&gt; all[\"if &lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; font-family: monospace; word-break: break-word;'&gt;--all&lt;/code&gt;, enumerate&lt;br&gt;**all** CSMs for each SLM\"];\n  all --&gt; export[\"**export** individual CSMs as&lt;br&gt;&lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; font-family: monospace; word-break: break-word;'&gt;--poscar --xdatcar&lt;/code&gt;\"];\n  export --&gt; visualize[\"**visualize** CSMs using&lt;br&gt;&lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; font-family: monospace; word-break: break-word;'&gt;--scatter --interact&lt;/code&gt;\"]</code></pre>"},{"location":"cli/#csmcar","title":"CSMCAR","text":"<p>CSMCAR is a plain text file that provides extra information for generating and analyzing CSMs. <code>crystmatch</code> will not read a CSMCAR file unless it is specified in the <code>--extra</code> option, as:</p> <pre><code>crystmatch --enumerate graphite.poscar diamond.poscar 2 0.3 --extra CSMCAR.txt\n</code></pre> <p>CSMCAR may contain at most three fields:</p> <ul> <li>The elastic tensors</li> <li>The atomic weights used to defined the shuffle distance</li> <li>The orientation relationship used to benchmark CSMs</li> </ul>"},{"location":"cli/#elastic-tensors","title":"Elastic tensors","text":"<p>If you want to use the strain energy density \\(w\\), instead of the root-mean-square strain \\(\\bar\\varepsilon\\), as the pruning criterion, the CSMCAR file should contain elastic tensors of the initial and final structures. They must be specified as \\(6\\times 6\\) symmetric matrices (Voigt notation) as:</p> <pre><code># ./CSMCAR.txt\n\ninitial elastic tensor:\n    XX    268.6236     46.1585     47.5328      0.6739      0.9388     -1.8586\n    YY     46.1585    268.5367     48.5034      0.1023      1.8528     -3.2724\n    ZZ     47.5328     48.5034    268.7187     -0.0438      0.8634     -1.6993\n    XY      0.6739      0.1023     -0.0438     44.0620     -1.7433      1.4076\n    YZ      0.9388      1.8528      0.8634     -1.7433     42.5860     -0.5327\n    ZX     -1.8586     -3.2724     -1.6993      1.4076     -0.5327     42.2492\n\nfinal elastic tensor:\n    XX    262.9004    128.7075    102.3784    -22.5882      5.6997      7.9351\n    YY    128.7075    262.8757    102.3694    -21.7608      8.0470      5.6492\n    ZZ    102.3784    102.3694    295.9447     32.4762    -19.2804    -19.2551\n    XY    -22.5882    -21.7608     32.4762    138.7953      5.1622      5.4153\n    YZ      5.6997      8.0470    -19.2804      5.1622    104.6801     34.9596\n    ZX      7.9351      5.6492    -19.2551      5.4153     34.9596    104.6258\n</code></pre> <p>The axis name must be given in each row. The above CSMCAR is in the order of <code>XX</code>, <code>YY</code>, <code>ZZ</code>, <code>XY</code>, <code>YZ</code>, <code>ZX</code>, which is the same as VASP. However, the elastic tensors provided by Materials Project are in the order of <code>XX</code>, <code>YY</code>, <code>ZZ</code>, <code>YZ</code>, <code>ZX</code>, <code>XY</code>, in which case you should write the axis name in the same order.</p> <p>Note</p> <p>Once you use <code>--extra</code> or <code>-e</code> and provide the elastic tensors, the <code>--enumerate</code> mode will interpret its last parameter <code>MAX_STRAIN</code> as the maximum strain energy density, not the maximum root-mean-square strain (RMSS). The unit of <code>MAX_STRAIN</code> is the same as the unit of the elastic tensors in the CSMCAR file.</p> <p>If you want to use the RMSS as the pruning criterion, and then calculate the strain energy density \\(w\\) for each CSM, please use <code>crystmatch</code> as a Python module.</p>"},{"location":"cli/#atomic-weights","title":"Atomic weights","text":"<p>If the initial and final structures involve more than one atomic species, you can specifie their atomic weights in the CSMCAR file as:</p> <pre><code># ./CSMCAR.txt\n\natomic weights:\n    Cs      Cl\n    132.9   35.45\n</code></pre> <p><code>crystmatch</code> will normalize these weights and use them to define the shuffle distance</p> \\[ d(\\mathcal{J})=\\min_{\\mathbf{t}_0 \\in \\mathbb{R}^{3}}\\sqrt{\\sum_{i=1}^{\\tilde Z}\\theta_i\\left|\\tilde{\\mathcal{J}}(\\tilde{\\mathbf{a}}_i)+\\mathbf{t}_0-\\tilde{\\mathbf{a}}_i\\right|^2}, \\] <p>where \\(\\mathcal{J}\\colon\\mathcal{A}\\to\\mathcal{B}\\) is a CSM, \\(\\tilde{\\mathcal{J}}\\colon\\tilde{\\mathcal{A}}\\to\\tilde{\\mathcal{B}}\\) its standard shuffle, \\(\\tilde Z\\) its period, \\(\\tilde{\\mathbf{a}}_i\\in\\tilde{\\mathcal{A}}\\) the position of the \\(i\\)-th atom, and \\(\\theta_i\\) the normalized weight of the \\(i\\)-th atom. See this paper for more details.</p>"},{"location":"cli/#orientation-relationship","title":"Orientation relationship","text":"<p>To benchmark CSMs with a given orientation relationship, two parameters must be specified:</p> <ol> <li> <p>The orientation relationship, provided in the CSMCAR file as:</p> <pre><code># ./CSMCAR.txt\n\norientation relationship:\n    1 0 0 || -1 0 0\n    0 1 0 || 0 -1 0\n</code></pre> <p>Here, exactly two rows after <code>orientation relationship</code> will be read. Each row specifies a parallelism between two crystal directions of the initial and final structures. These crystal directions are denoted as Miller indices</p> \\[ [hk\\ell]=h\\mathbf{a}+k\\mathbf{b}+\\ell\\mathbf{c}, \\] <p>where \\(\\mathbf{a}, \\mathbf{b}, \\mathbf{c}\\) are the lattice vectors of the conventional cell. They are determined by Spglib and depend only on the crystal systems of the initial and final structures.</p> <p>Caveat</p> <p>The conventional cell is not the primitive cell if the Bravais lattice is base-centered, face-centered, or body-centered. We recommend using</p> <pre><code>crystmatch --read CSMLIST.npz 0 --interact\n</code></pre> <p>to check if the conventional \\(\\mathbf{a}, \\mathbf{b}, \\mathbf{c}\\) is the same as you expect.</p> </li> <li> <p>The assumption used to determine the orientation of the final structure, must be one of the following:</p> <ul> <li> <p><code>'norot'</code>: The final lattice is deformed from the initial one without rotation.</p> </li> <li> <p><code>'uspfixed'</code>: One of the two uniformly-scaled planes (USPs) is fixed.</p> </li> </ul> <p>For more details, see the supplemental material of this paper.</p> </li> </ol> <p>If you have a <code>CSMLIST.npz</code> file and a <code>CSMCAR.txt</code> file containing an orientation relationship, you can run:</p> <p><pre><code>crystmatch --read CSMLIST.npz --extra CSMCAR.txt --orientation 'norot'\n</code></pre> or</p> <pre><code>crystmatch --read CSMLIST.npz --extra CSMCAR.txt --orientation 'uspfixed'\n</code></pre>"},{"location":"cli/#all-options","title":"All options","text":"<pre><code>crystmatch [--help] [--version] \\                               # package information\n           [--extra CSMCAR] [--tol TOL] \\                       # global settings\n           [--enumerate POSCAR_I POSCAR_F MAX_MU MAX_STRAIN] \\  # enumerate CSMs\n           [--read CSMLIST [IND1 IND2 ...]] \\                   # read CSMs from NPZ\n           [--direct POSCAR_I POSCAR_F] [--literal] \\           # single CSM analysis\n           [--all MAX_D] \\                                      # exhaustive enumeration\n           [--interact [SIZE]] \\                                # 3D interactive plot\n           [--poscar [ASSUM]] [--xdatcar [ASSUM]] \\             # export individual CSMs\n           [--orientation ASSUM] \\                              # orientation analysis\n           [--csv] [--scatter]                                  # summarize and visualize\n</code></pre> <p>If you are not familiar with <code>crystmatch</code>, we recommend you first read the tutorial and then come back to this page for a detailed explanation of the options.</p> <ul> <li> <p><code>-h</code>, <code>--help</code></p> <p>Show help message and exit.</p> </li> <li> <p><code>-V</code>, <code>-v</code>, <code>--version</code></p> <p>Show program's version number and exit.</p> </li> <li> <p><code>-E POSCAR_I POSCAR_F MAX_MU MAX_STRAIN</code>, <code>--enumerate POSCAR_I POSCAR_F MAX_MU MAX_STRAIN</code></p> <p>Enumerate representative CSMs (those with the minimal shuffle distance among all CSMs that share the same deformation gradient) between the initial and final structures defined in <code>POSCAR_I</code> and <code>POSCAR_F</code>, with <code>MAX_MU</code> and <code>MAX_STRAIN</code> as upper bounds for the multiplicity and RMSS. If elastic tensors are provided, <code>MAX_STRAIN</code> is instead interpreted as the maximum strain energy density (with the same unit as in the CSMCAR file).</p> </li> <li> <p><code>-R CSMLIST [IND1 IND2 ...]</code>, <code>--read CSMLIST [IND1 IND2 ...]</code></p> <p>Read CSMs from an existing NPZ file <code>CSMLIST</code>. If the indices <code>IND1 IND2 ...</code> are provided, only load the CSMs with the given indices.</p> </li> <li> <p><code>-D POSCAR_I POSCAR_F</code>, <code>--direct POSCAR_I POSCAR_F</code></p> <p>Directly read a single CSM from a pair of POSCAR files <code>POSCAR_I</code> and <code>POSCAR_F</code>. The CSM is determined such that each cell vector or atomic position in <code>POSCAR_I</code> is mapped to the corresponding one (with the same row index) in <code>POSCAR_F</code>. Make sure that the cell vectors and atomic positions in <code>POSCAR_I</code> and <code>POSCAR_F</code> are ordered as you expect.</p> <p>Caveat</p> <p>When writing the POSCAR, some softwares may add or subtract integers (cell vectors) to the fractional (cartesian) coordinates of the atoms to make them within the cell, thus altering the CSM. To avoid this issue, <code>crystmatch</code> will automatically add integers to the fractional coordinates to minimize the shuffle distance. However, if you are confident that the fractional coordinates represent the true initial and final atomic positions, use <code>--literal</code> to keep the original fractional coordinates.</p> </li> <li> <p><code>-l</code>, <code>--literal</code></p> <p>Keep the original fractional coordinates in the POSCAR files when using <code>--direct</code>.</p> </li> <li> <p><code>-e CSMCAR</code>, <code>--extra CSMCAR</code></p> <p>Load extra parameters from a CSMCAR file, including the elastic tensors, the atomic weights, and the orientation relationship used to benchmark CSMs.</p> </li> <li> <p><code>-a MAX_D</code>, <code>--all MAX_D</code></p> <p>Additionally enumerate all CSMs (instead of only the representative or read ones) for each SLM, with <code>MAX_D</code> as the upper bound for the shuffle distance.</p> </li> <li> <p><code>-t TOL</code>, <code>--tol TOL</code></p> <p>Tolerance in angstroms for detecting symmetry. Default is <code>1e-3</code>.</p> </li> <li> <p><code>-i [SIZE]</code>, <code>--interact [SIZE]</code></p> <p>Interactively visualize each CSM using a 3D plot. <code>SIZE</code> specifies the radius of the cluster to display, which we recommend to be smaller than <code>2.0</code>. Use <code>SIZE = 0</code> to display the cell contents only. Default is <code>1.2</code>.</p> <p>Caveat</p> <p>The interactive plot may not work properly in some environments, such as Windows Subsystem for Linux (WSL) or remote servers.</p> </li> <li> <p><code>-o ASSUM</code>, <code>--orientation ASSUM</code></p> <p>Calculate the deviation angle from the given orientation relationship for each CSM. Only works when the orientation relationship is provided by <code>--extra</code>. The orientation of the final structure is determined by <code>ASSUM</code>, which must be specified as <code>'norot'</code> or <code>'uspfixed'</code>.</p> </li> <li> <p><code>-p [ASSUM]</code>, <code>--poscar [ASSUM]</code></p> <p>Export each enumerated/read CSM as a pair of POSCAR files. <code>ASSUM</code> must be <code>'norot'</code> or <code>'uspfixed'</code>. Default is <code>'norot'</code>.</p> <p>Note</p> <p>If <code>ASSUM = 'uspfixed'</code>, two final structures (instead of one) are created since there are two USPs.</p> </li> <li> <p><code>-x [ASSUM]</code>, <code>--xdatcar [ASSUM]</code></p> <p>Export each CSM as an XDATCAR file with 50 frames, similar to <code>--poscar</code>.</p> </li> </ul> <p>These options are automatically enabled when using <code>--enumerate</code>, <code>--all</code> or <code>--orientation</code>:</p> <ul> <li> <p><code>-c</code>, <code>--csv</code></p> <p>Create CSV file containing the multiplicities, RMSS, shuffle distances, estimated strain energy densities (if elastic tensors are provided) and deviation angles (if <code>--orientation</code> is used) of the enumerated/read CSMs. </p> </li> <li> <p><code>-s</code>, <code>--scatter</code></p> <p>Create scatter plot in PDF format containing all enumerated/read CSMs.</p> </li> </ul>"}]}