{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tutorial","text":"<p>Abstract</p> <p>A solid-solid phase transition establishes an atom-to-atom correspondence between the initial and final crystal structures \\(\\mathcal A\\) and \\(\\mathcal B\\). Such correspondence is called a crystal-structure match (CSM)<sup>1</sup>. A CSM can be described by a pair of POSCAR files, which specifies how the lattice deforms from \\(\\mathcal A\\) to \\(\\mathcal B\\) and the correspondence between atoms in a supercell of \\(\\mathcal A\\) and those in \\(\\mathcal B\\).</p> <p>The main functions of <code>crystmatch</code> are as follows:</p> <ul> <li> <p>Enumeration:</p> <ul> <li>Provide a complete list of representative<sup>1</sup> CSMs between two given crystal structures, with user-specified upper bounds on the multiplicity<sup>1</sup> and root-mean-square strain (RMSS).</li> <li>(In progress) Provide a complete list of CSMs with user-specified upper bounds on the multiplicity, RMSS, and root-mean-square displacement (RMSD).</li> </ul> </li> <li> <p>Analysis:</p> <ul> <li>Read a CSM from a pair of POSCAR files, and save CSMs in the same format.</li> <li>Score CSMs by RMSS and RMSD.</li> <li>Benchmark a CSM by its deviation angle from an orientation relationship (OR).</li> </ul> </li> </ul> <p>Congruent CSMs (those differ only by a space-group transformation) are identified and excluded from the enumeration using the <code>spglib</code> library by Atsushi Togo et al.</p>"},{"location":"#installation","title":"Installation","text":"<p>Make sure you have Python 3.9 or later installed. You can check it by running:</p> <pre><code>python3 --version\n</code></pre> <p>To install the latest version of <code>crystmatch</code>, run:</p> <pre><code>pip3 install --upgrade crystmatch\n</code></pre> <p>or use <code>conda install -c conda-forge crystmatch</code> to install and <code>conda update -c conda-forge crystmatch</code> to update, if you prefer using <code>conda</code>.</p> <p>Check whether <code>crystmatch</code> is successfully installed:</p> <pre><code>crystmatch --version\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>To run <code>crystmatch</code>, one of the following modes must be selected:</p> <ol> <li>Enumeration mode: Generate a list of CSMs, save them to a <code>CSM_LIST.npz</code> file, and perform preliminary analysis. The initial and final crystal structures must be specified in the form of POSCAR files.</li> <li>Read mode: Read CSMs from a <code>CSM_LIST.npz</code> file. You can export specific CSMs to POSCARs, perform OR analysis, generate CSV tables of CSM properties, and visualize the RMSD-RMSS-multiplicity distribution in a 2D scatter plot.</li> <li>Single-CSM mode: Directly determine a single CSM by two POSCAR files (must have the same number and species of atoms) and perform detailed analysis.</li> </ol> <p>We strongly recommend starting with the examples provided below. If you are still confused, run <code>crystmatch</code> directly in the command line without any arguments for an interactive calculation. To see all available options, run:</p> <pre><code>crystmatch --help\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#enumerating-csms","title":"Enumerating CSMs","text":"<p>To generate a list of representative [1] CSMs between two crystal structures stored in <code>./fcc</code> and <code>./bcc</code>, with multiplicity upper bound <code>MAX_MU = 2</code> and RMSS upper bound <code>MAX_RMSS = 0.4</code>, run:</p> <pre><code>crystmatch --initial fcc --final bcc --enumeration 2 0.4\n</code></pre> <p>Note</p> <p>We recommend you to try <code>MAX_MU &lt;= 2</code> and <code>MAX_RMSS = 0.4</code> first, and then gradually adjust these upper bounds (usually by increasing <code>MAX_MU</code> and decreasing <code>MAX_RMSS</code>) to obtain desired results. Otherwise, the enumeration may take a very long time, or find no CSMs at all.</p> <p>The following files will be created in the current directory:</p> <pre><code>./\n\u251c\u2500\u2500 CSM_LIST-m2s0.40.npz       # stores the enumerated CSMs and metadata.\n\u251c\u2500\u2500 PLOT-m2s0.40.pdf           # shows the RMSD-RMSS distribution of the CSMs.\n\u2514\u2500\u2500 TABLE-m2s0.40.csv          # shows the multiplicity, RMSS, and RMSD of each CSM.\n</code></pre>"},{"location":"#exporting-csms-from-an-npz-file","title":"Exporting CSMs from an NPZ file","text":"<p>After enumeration, you can see the properties of CSMs in the CSV file, which also contains their indices in the NPZ file. If you want to export the CSMs with indices <code>7</code> and <code>10</code> in <code>CSM_LIST-foo.npz</code>, run:</p> <pre><code>crystmatch --read CSM_LIST-foo.npz --export 7 10\n</code></pre> <p>Two folders will be created in the current directory, each containing a pair of POSCAR files representing the CSM. The current directory will look like this:</p> <pre><code>./\n\u251c\u2500\u2500 CSM_7/\n\u2502   \u251c\u2500\u2500 POSCAR_I\n\u2502   \u2514\u2500\u2500 POSCAR_F\n\u2514\u2500\u2500 CSM_10/\n    \u251c\u2500\u2500 POSCAR_I\n    \u2514\u2500\u2500 POSCAR_F\n</code></pre>"},{"location":"#orientation-relationship-analysis","title":"Orientation relationship analysis","text":"<p>To benchmark CSMs in <code>CSM_LIST-foo.npz</code> by their deviation angles from the OR \\((111)_A\\parallel(110)_B,[1\\bar{1}0]_A\\parallel[001]_B\\), run:</p> <pre><code>crystmatch --read CSM_LIST-foo.npz --orientation 1 1 1 1 1 0 1 -1 0 0 0 1\n</code></pre> <p>Note that the arguments after <code>--orientation</code> must be Cartesian coordinates.</p> <p>The ORs are determined via the rotation-free<sup>1</sup> manner by default, and you can also use <code>--uspfix</code> to determine ORs via the USF-fixed<sup>1</sup> manner.</p>"},{"location":"#single-csm-analysis","title":"Single-CSM analysis","text":"<p>To analyze a single CSM defined by two POSCAR files, run:</p> <pre><code>crystmatch --initial POSCAR1 --final POSCAR2 --single\n</code></pre> <p><code>crystmatch</code> will also save the rigid-transformation optimized (with rotation-free orientation and RMSD-minimized overall position) CSM in the current directory like this:</p> <pre><code>./\n\u2514\u2500\u2500 CSM_single/\n    \u251c\u2500\u2500 POSCAR1\n    \u2514\u2500\u2500 POSCAR2-optimized\n</code></pre> <ol> <li> <p>FC Wang, QJ Ye, YC Zhu, and XZ Li, Physical Review Letters 132, 086101 (2024) \u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"about/","title":"About","text":"<p><code>crystmatch</code> is developed by the Xin-Zheng Li (\u674e\u65b0\u5f81) Group at the School of Physics, Peking University. Our research focuses on computer simulations of material properties, covering a wide range of first-principles methods in condensed matter physics and theoretical chemistry, as well as some fundamental theories in statistical physics. These methods and theories include, for example:</p> <ul> <li> <p>Path-integral methods for the description of statistical nuclear quantum effects (closed-path &amp; open-path, distinguishable particles and bosonic or fermionic systems),</p> </li> <li> <p>The instanton method for quantum tunneling,</p> </li> <li> <p>The initial value representation method for quantum dynamics,</p> </li> <li> <p>Crystal structure matching for solid-solid phase transitions,</p> </li> <li> <p>Non-equilibrium Green's function theory for quantum friction and quantum dragging, and</p> </li> <li> <p>The Yang-Lee theory for phase transitions.</p> </li> </ul> <p>If you use <code>crystmatch</code> in your research, please cite the following paper:</p> <p>[1] FC Wang, QJ Ye, YC Zhu, and XZ Li, Physical Review Letters 132, 086101 (2024)</p> <p>In addition to our research group, we would like to express our gratitude to:</p> <ul> <li> <p>Dr. F\u00e9lix Therrien, for his pioneering work and guidance on orientation analysis;</p> </li> <li> <p>Yi-Chi Zhang (\u5f20\u4ea6\u5f1b), for his crucial feedback on RMSD calculations;</p> </li> <li> <p>Wuji Han (\u97e9\u65e0\u6781) and Zhilin Chang (\u5e38\u7a1a\u6797), for their contributions to parallelization.</p> </li> </ul> <p>You are welcome to contact us at <code>wfc@pku.edu.cn</code> for any questions, feedback or comments regarding <code>crystmatch</code>.</p>"},{"location":"api/","title":"Python API","text":""},{"location":"api/#data-structures","title":"Data structures","text":"Type Structure Description <code>cryst</code> <code>(lattice, species, positions)</code> A crystal structure described by a primitive cell <code>lattice</code>, atomic species <code>species</code>, and fractional coordinates <code>positions</code>. Cell vectors are rows of <code>lattice</code>. <code>slm</code> <code>(hA, hB, q)</code> A sublattice match (SLM) described by an integer-matrix triplet."},{"location":"api/#functions","title":"Functions","text":""},{"location":"api/#crystmatch.enumeration","title":"<code>crystmatch.enumeration</code>","text":"<p>Enumerate SLMs and CSMs.</p>"},{"location":"api/#crystmatch.enumeration.all_hnf","title":"<code>all_hnf(det)</code>","text":"<p>Enumerate all 3*3 column Hermite normal forms (HNFs) with given determinant.</p> <p>Parameters:</p> Name Type Description Default <code>det</code> <code>int</code> <p>The determinant of HNFs.</p> required <p>Returns:</p> Name Type Description <code>l</code> <code>(..., 3, 3) array of ints</code> <p>Contains all HNFs with determinant <code>det</code>.</p>"},{"location":"api/#crystmatch.enumeration.cell_reduce","title":"<code>cell_reduce(c)</code>","text":"<p>Shorten the cell vectors of <code>c</code>.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array</code> <p>The cell to be reduced, whose columns are cell vectors.</p> required <p>Returns:</p> Name Type Description <code>cc</code> <code>(3, 3) array</code> <p>The Niggli cell, with shortest right-handed cell vectors.</p> <code>q</code> <code>(3, 3) array of ints</code> <p>The unimodular matrix satisfying <code>cc = c @ q</code>.</p>"},{"location":"api/#crystmatch.enumeration.create_common_supercell","title":"<code>create_common_supercell(crystA, crystB, slm)</code>","text":"<p>Create supercell structures representing \\(\\mathcal{A}\\) (initial structure)and \\(\\sqrt{S^{\\text{T}} S}S^{-1}\\mathcal{B}\\)         (rotation-free final structure). Also return the half-distorted supercell and translation cell.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slm</code> <code>slm</code> <p>The SLM of the CSM.</p> required <p>Returns:</p> Name Type Description <code>crystA_sup</code> <code>cryst</code> <p>The supercell of \\(\\mathcal{A}\\).</p> <code>crystB_sup_final</code> <code>cryst</code> <p>The supercell of \\(\\sqrt{S^{\\text{T}} S}\\mathcal{A}\\), which equals the supercell of \\((S^{\\text{T}} S)^{-1/2}\\mathcal{B}\\).</p> <code>c_sup_half</code> <code>(3, 3) array of floats</code> <p>The half-distorted supercell, which equals the supercel of \\((S^{\\text{T}} S)^{1/4}\\mathcal{A}\\) and that of \\((S^{\\text{T}} S)^{-1/4}\\mathcal{B}\\).</p> <code>f_translate</code> <code>(3, 3) array of floats</code> <p>The translation cell (fractional coordinates) of the shuffle whose lattice is generated by<code>c_sup_half</code>.</p>"},{"location":"api/#crystmatch.enumeration.deformation_gradient","title":"<code>deformation_gradient(crystA, crystB, slmlist)</code>","text":"<p>Compute the deformation gradient matrices of given IMTs.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slmlist</code> <code>list of slm</code> <p>The IMTs.</p> required <p>Returns:</p> Name Type Description <code>slist</code> <code>(..., 3, 3) array</code> <p>A list of deformation gradient matrices.</p>"},{"location":"api/#crystmatch.enumeration.enumerate_slm","title":"<code>enumerate_slm(crystA, crystB, mu, kappa_max, tol=0.001, kappa=rmss, likelihood_ratio=100.0, verbose=1)</code>","text":"<p>Enumerating all SLMs of multiplicity <code>mu</code> with <code>kappa</code> smaller than <code>kappa_max</code>.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>crystB</code> <code>cryst</code> <p>The final crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>mu</code> <code>int</code> <p>The multiplicity of SLMs to enumerate.</p> required <code>kappa_max</code> <code>float</code> <p>A positive threshold value of <code>kappa</code> to determine the range of singular values to generate.</p> required <code>tol</code> <code>float</code> <p>The tolerance for determining the pure rotation group of the crystal structures. Default is 1e-3.</p> <code>0.001</code> <code>kappa</code> <code>callable</code> <p>A function that quantifies the strain of a matrix according to its singular values.             Default is <code>rmss</code>, which computes the root-mean-square strain.</p> <code>rmss</code> <code>likelihood_ratio</code> <code>float</code> <p>The expected likelihood ratio of the enumeration being complete and incomplete. Default is 1e2.</p> <code>100.0</code> <code>verbose</code> <code>int</code> <p>The level of verbosity. Default is 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>slmlist</code> <code>list of slm</code> <p>Contains triplets of integer matrices like <code>(hA, hB, q)</code>, representing incongruent SLMs.</p>"},{"location":"api/#crystmatch.enumeration.get_pure_rotation","title":"<code>get_pure_rotation(cryst, tol=0.001)</code>","text":"<p>Find all pure rotations appeared in the space group of <code>cryst</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cryst</code> <code>3 - tuple</code> <p><code>(lattice, species, positions)</code>, representing the crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>tol</code> <code>float</code> <p>The tolerance for <code>spglib</code> symmetry detection; default is 1e-3.</p> <code>0.001</code> <p>Returns:</p> Name Type Description <code>g</code> <code>(..., 3, 3) array of ints</code> <p>A point group of the first kind, containing all pure rotations appeared in the space group of <code>cryst</code>,             elements of which are integer matrices (under fractional coordinates).</p>"},{"location":"api/#crystmatch.enumeration.hnf_int","title":"<code>hnf_int(m, return_q=True)</code>","text":"<p>Decompose square integer matrix <code>m</code> into product of HNF matrix <code>h</code> and unimodular matrix <code>q</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>(N, N) array of ints</code> <p>The integer matrix to decompose, with positive determinant.</p> required <code>return_q</code> <code>bool</code> <p>Whether to return the unimodular matrix <code>q</code>. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>h</code> <code>(N, N) array of ints</code> <p>The column-style Hermite normal form of <code>m</code>.</p> <code>q</code> <code>(N, N) array of ints</code> <p>The unimodular matrix satisfying <code>m</code> = <code>h @ q</code>.</p>"},{"location":"api/#crystmatch.enumeration.hnf_rational","title":"<code>hnf_rational(m, max_divisor=10000)</code>","text":"<p>The Hermite normal form (HNF) of full-row-rank rational matrix <code>m</code> (not necessarily square or integer).</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>(M, N) array_like, M &lt;= N</code> <p>The full-row-rank rational matrix to reduce.</p> required <code>max_divisor</code> <code>int</code> <p>A positive integer. The least common multiple of all divisors in <code>m</code> should not be greater than <code>max_divisor</code>.</p> <code>10000</code> <p>Returns:</p> Name Type Description <code>h</code> <code>(M, N) array</code> <p>The HNF of <code>m</code> obtained via elementary column operations over integers.</p>"},{"location":"api/#crystmatch.enumeration.int_arrays_to_pair","title":"<code>int_arrays_to_pair(crystA, crystB, slm, p, ks, centered=True)</code>","text":"<p>Convert the integer arrays representation <code>(slm, p, translations)</code> of a CSM to a pair of crysts.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slm</code> <code>slm</code> <p>The SLM of the CSM.</p> required <code>p</code> <code>(Z, ) array of ints</code> <p>The permutaion of the shuffle.</p> required <code>ks</code> <code>(3, Z) array of ints</code> <p>The lattice-vector translations of the shuffle.</p> required <code>centered</code> <code>bool</code> <p>Whether to make the centers of <code>crystA_sup</code> and <code>crystB_sup_final</code> coincide. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>crystA_sup</code> <code>cryst</code> <p>The initial structure, whose lattice vectors and atoms are matched to <code>crystB_sup</code> according to the CSM.</p> <code>crystB_sup_final</code> <code>cryst</code> <p>The final structure, whose lattice vectors and atoms are matched to <code>crystA_sup</code> according to the CSM, with rotation-free orientation.</p>"},{"location":"api/#crystmatch.enumeration.int_fact","title":"<code>int_fact(n)</code>","text":"<p>Factorize positive integer <code>n</code> into products of two integers.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The integer to be factorized.</p> required <p>Returns:</p> Name Type Description <code>l</code> <code>list of 2-tuples of ints</code> <p>Contains all <code>(a, b)</code> such that a*b=n.</p>"},{"location":"api/#crystmatch.enumeration.int_vec_inside","title":"<code>int_vec_inside(c)</code>","text":"<p>Integer vectors inside the cell <code>c</code> whose elements are integers.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array of ints</code> <p>A matrix whose columns are integer cell vectors.</p> required <p>Returns:</p> Name Type Description <code>v_int</code> <code>(3, ...) array of ints</code> <p>Its columns are vectors satisfying <code>v = c @ k</code>, where <code>k[0]</code>, <code>k[1]</code>, <code>k[2]</code> \\(\\in [0, 1)\\).</p>"},{"location":"api/#crystmatch.enumeration.load_poscar","title":"<code>load_poscar(filename, to_primitive=True, tol=0.001, verbose=True)</code>","text":"<p>Load the crystal structure from a POSCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the POSCAR file to be read.</p> required <code>to_primitive</code> <code>bool</code> <p>Using the primitive cell instead of the cell given by the POSCAR file. Default is True.</p> <code>True</code> <code>tol</code> <code>str</code> <p>The tolerance for <code>spglib</code> symmetry detection; default is 1e-3.</p> <code>0.001</code> <p>Returns:</p> Name Type Description <code>cryst</code> <code>cryst</code> <p>The loaded crystal structure, consisting of the lattice vectors, species, and positions.</p>"},{"location":"api/#crystmatch.enumeration.matrix_gcd","title":"<code>matrix_gcd(m1, m2, max_divisor=10000)</code>","text":"<p>Return a greatest common divisor of rational matrices <code>m1</code> and <code>m2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m1</code> <code>(3, 3) array_like</code> <p>Nonsingular rational matrices.</p> required <code>m2</code> <code>(3, 3) array_like</code> <p>Nonsingular rational matrices.</p> required <code>max_divisor</code> <code>int</code> <p>A positive integer. The least common multiple of all divisors in <code>m</code> should not be greater than <code>max_divisor</code>.</p> <code>10000</code> <p>Returns:</p> Name Type Description <code>d</code> <code>(3, 3) array</code> <p>The greatest common divisor of <code>m1</code> and <code>m2</code> in Hermite normal form.</p>"},{"location":"api/#crystmatch.enumeration.matrix_lcm","title":"<code>matrix_lcm(m1, m2)</code>","text":"<p>Return a least common multiple of integer matrices <code>m1</code> and <code>m2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m1</code> <code>(3, 3) array_like</code> <p>Nonsingular integer matrices.</p> required <code>m2</code> <code>(3, 3) array_like</code> <p>Nonsingular integer matrices.</p> required <p>Returns:</p> Name Type Description <code>m</code> <code>(3, 3) array</code> <p>The least common multiple of <code>m1</code> and <code>m2</code> in Hermite normal form.</p>"},{"location":"api/#crystmatch.enumeration.minimize_rmsd","title":"<code>minimize_rmsd(crystA, crystB, slm)</code>","text":"<p>Minimize the RMSD with fixed SLM, variable permutation, overall and lattice-vector translations.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>crystB</code> <code>cryst</code> <p>The final crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>slm</code> <code>slm</code> <p>Triplets of integer matrices like <code>(hA, hB, q)</code>, representing a SLM.</p> required <p>Returns:</p> Name Type Description <code>rmsd</code> <code>float</code> <p>The minimum atomic displacement (RMSD) between \\((S^{\\text{T}} S)^{1/4}\\mathcal{A}\\) and \\((S^{\\text{T}} S)^{-1/4}\\mathcal{B}\\).</p> <code>p</code> <code>(Z, ) array of ints</code> <p>The permutation of the atoms in <code>pB_sup</code> that minimizes the RMSD.</p> <code>ks</code> <code>(3, Z) array of ints</code> <p>The lattice-vector translations (fractional coordinates) of the atoms in <code>pB_sup[:,p]</code> that minimizes the RMSD.</p> <code>t0</code> <code>(3, ) array of floats</code> <p>The overall translation on <code>pB</code> that minimizes the RMSD.</p>"},{"location":"api/#crystmatch.enumeration.minimize_rmsd_t","title":"<code>minimize_rmsd_t(c, species, pA, pB)</code>","text":"<p>Minimize the RMSD with fixed SLM, overall translation, variable permutation and lattice-vector translations.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array</code> <p>The matrix whose columns are cell vectors of both crystal structures.</p> required <code>species</code> <code>(N,) array of strs</code> <p>The array that specifies the type of each ion.</p> required <code>pA</code> <code>(3, N) array</code> <p>The matrices whose columns are fractional coordinates of atoms.</p> required <code>pB</code> <code>(3, N) array</code> <p>The matrices whose columns are fractional coordinates of atoms.</p> required <p>Returns:</p> Name Type Description <code>rmsd</code> <code>float</code> <p>The minimized RMSD.</p> <code>p</code> <code>(Z, ) array of ints</code> <p>The permutation of the atoms in <code>pB</code> that minimizes the RMSD.</p> <code>ks</code> <code>(3, Z) array of ints</code> <p>The lattice-vector translations of the atoms in <code>pB[:,p]</code> that minimizes the RMSD.</p>"},{"location":"api/#crystmatch.enumeration.minimize_rmsd_tp","title":"<code>minimize_rmsd_tp(c, pA, pB)</code>","text":"<p>Minimize the RMSD with fixed SLM, overall translation, permutation, and variable lattice-vector translations.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array</code> <p>The matrix whose columns are cell vectors of both crystal structures.</p> required <code>pA</code> <code>(3, N) array</code> <p>The matrices whose columns are fractional coordinates of atoms.</p> required <code>pB</code> <code>(3, N) array</code> <p>The matrices whose columns are fractional coordinates of atoms.</p> required <p>Returns:</p> Name Type Description <code>rmsd</code> <code>float</code> <p>The minimized RMSD.</p> <code>ks</code> <code>(3, Z) array of ints</code> <p>The lattice-vector translations (fractional coordinates) of the atoms in <code>pB</code> that minimizes the RMSD.</p>"},{"location":"api/#crystmatch.enumeration.rmss","title":"<code>rmss(slist)</code>","text":"<p>Root-mean-square strains of given deformation gradient matrices.</p> <p>Parameters:</p> Name Type Description Default <code>slist</code> <code>(..., 3, 3) array</code> <p>A list of deformation gradient matrices.</p> required <p>Returns:</p> Name Type Description <code>rmss</code> <code>(...) array</code> <p>Root-mean-square strains.</p>"},{"location":"api/#crystmatch.enumeration.save_poscar","title":"<code>save_poscar(filename, cryst, crystname=None)</code>","text":"<p>Save the crystal structure to a POSCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save, must not already exist in current directory. If <code>filename = None</code>, a string will be returned instead.</p> required <code>cryst</code> <code>cryst</code> <p>The crystal structure to be saved, consisting of the lattice vectors, species, and positions.</p> required <code>crystname</code> <code>str</code> <p>A system description to write to the comment line of the POSCAR file. If <code>crystname = None</code>, <code>filename</code> will be used.</p> <code>None</code>"},{"location":"api/#crystmatch.enumeration.species_poscar_format","title":"<code>species_poscar_format(species)</code>","text":"<p>Examine whether a species array is sorted. If so, convert it to the POSCAR format.</p> <p>Parameters:</p> Name Type Description Default <code>species</code> <code>(N,) array of str</code> <p>The species array.</p> required <p>Returns:</p> Name Type Description <code>species_unique</code> <code>(M,) array of str</code> <p>The unique species in the order of their first appearance in <code>species</code>.</p> <code>species_counts</code> <code>(M,) array of int</code> <p>The number of occurrences of each unique species in <code>species</code>.</p>"},{"location":"api/#crystmatch.enumeration.standardize_slm","title":"<code>standardize_slm(slm, gA, gB)</code>","text":"<p>The representative SLM of the congruence class of <code>slm</code>.</p> <p>Parameters:</p> Name Type Description Default <code>slm</code> <code>slm</code> <p><code>(hA, hB, q)</code>, representing a SLM.</p> required <code>gA</code> <code>(..., 3, 3) array of ints</code> <p>The rotation group of the initial crystal structure, whose elements are             integer matrices under fractional coordinates.</p> required <code>gB</code> <code>(..., 3, 3) array of ints</code> <p>The rotation group of the final crystal structure, whose elements are             integer matrices under fractional coordinates.</p> required <p>Returns:</p> Name Type Description <code>slm0</code> <code>slm</code> <p>The representative of the congruence class of <code>slm</code>.</p> <code>len_cl</code> <code>int</code> <p>The size of the congruence class of <code>slm</code>.</p>"},{"location":"api/#crystmatch.enumeration.unique_filename","title":"<code>unique_filename(message, filename)</code>","text":"<p>Get a unique filename by appending a number to the end of the given filename.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to be modified.</p> required <code>message</code> <code>str</code> <p>A message to print before the filename.</p> required <p>Returns:</p> Name Type Description <code>new_filename</code> <code>str</code> <p>The modified filename with a unique number appended.</p>"},{"location":"api/#crystmatch.enumeration.vector_reduce","title":"<code>vector_reduce(v, divisors)</code>","text":"<p>Minimizing the norm of <code>v</code> by adding and subtracting columns of <code>divisors</code>.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>(N,) array</code> <p>The vector to be reduced.</p> required <code>divisors</code> <code>(N, ...) array</code> <p>The vectors used to translate <code>v</code>.</p> required <p>Returns:</p> Name Type Description <code>vv</code> <code>(N,) array</code> <p>The reduced <code>v</code> with minimum Euclidean norm.</p>"},{"location":"api/#crystmatch.analysis","title":"<code>crystmatch.analysis</code>","text":"<p>Analyze and visualize CSMs.</p>"},{"location":"api/#crystmatch.analysis.all_hnf","title":"<code>all_hnf(det)</code>","text":"<p>Enumerate all 3*3 column Hermite normal forms (HNFs) with given determinant.</p> <p>Parameters:</p> Name Type Description Default <code>det</code> <code>int</code> <p>The determinant of HNFs.</p> required <p>Returns:</p> Name Type Description <code>l</code> <code>(..., 3, 3) array of ints</code> <p>Contains all HNFs with determinant <code>det</code>.</p>"},{"location":"api/#crystmatch.analysis.cell_reduce","title":"<code>cell_reduce(c)</code>","text":"<p>Shorten the cell vectors of <code>c</code>.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array</code> <p>The cell to be reduced, whose columns are cell vectors.</p> required <p>Returns:</p> Name Type Description <code>cc</code> <code>(3, 3) array</code> <p>The Niggli cell, with shortest right-handed cell vectors.</p> <code>q</code> <code>(3, 3) array of ints</code> <p>The unimodular matrix satisfying <code>cc = c @ q</code>.</p>"},{"location":"api/#crystmatch.analysis.create_common_supercell","title":"<code>create_common_supercell(crystA, crystB, slm)</code>","text":"<p>Create supercell structures representing \\(\\mathcal{A}\\) (initial structure)and \\(\\sqrt{S^{\\text{T}} S}S^{-1}\\mathcal{B}\\)         (rotation-free final structure). Also return the half-distorted supercell and translation cell.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slm</code> <code>slm</code> <p>The SLM of the CSM.</p> required <p>Returns:</p> Name Type Description <code>crystA_sup</code> <code>cryst</code> <p>The supercell of \\(\\mathcal{A}\\).</p> <code>crystB_sup_final</code> <code>cryst</code> <p>The supercell of \\(\\sqrt{S^{\\text{T}} S}\\mathcal{A}\\), which equals the supercell of \\((S^{\\text{T}} S)^{-1/2}\\mathcal{B}\\).</p> <code>c_sup_half</code> <code>(3, 3) array of floats</code> <p>The half-distorted supercell, which equals the supercel of \\((S^{\\text{T}} S)^{1/4}\\mathcal{A}\\) and that of \\((S^{\\text{T}} S)^{-1/4}\\mathcal{B}\\).</p> <code>f_translate</code> <code>(3, 3) array of floats</code> <p>The translation cell (fractional coordinates) of the shuffle whose lattice is generated by<code>c_sup_half</code>.</p>"},{"location":"api/#crystmatch.analysis.deform_distance","title":"<code>deform_distance(slmlist, s0, crystA, crystB)</code>","text":"<p>The Frobenius distance between deformation gradients.</p> <p>Parameters:</p> Name Type Description Default <code>slmlist</code> <code>list of slm</code> <p>A list of SLMs, each represented by a triplet of integer matrices like <code>(hA, hB, q)</code>.</p> required <code>s0</code> <code>slm</code> <p><code>(hA, hB, q)</code>, representing a SLM.</p> required <code>crystA</code> <code>cryst</code> <p><code>(lattice, species, positions)</code>, representing the crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>crystB</code> <code>cryst</code> <p><code>(lattice, species, positions)</code>, representing the crystal structure, usually obtained by <code>load_poscar</code>.</p> required <p>Returns:</p> Name Type Description <code>dlist</code> <code>(...,) array</code> <p>Contains Frobenius distances from <code>slmlist</code> to <code>s0</code>, where equivalent SLMs coincide.</p>"},{"location":"api/#crystmatch.analysis.deformation_gradient","title":"<code>deformation_gradient(crystA, crystB, slmlist)</code>","text":"<p>Compute the deformation gradient matrices of given IMTs.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slmlist</code> <code>list of slm</code> <p>The IMTs.</p> required <p>Returns:</p> Name Type Description <code>slist</code> <code>(..., 3, 3) array</code> <p>A list of deformation gradient matrices.</p>"},{"location":"api/#crystmatch.analysis.deviation_angle","title":"<code>deviation_angle(crystA, crystB, slmlist, r, uspfix=False)</code>","text":"<p>Calculate how much each SLM in <code>slmlist</code> differ from a given orientation relationship.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>crystB</code> <code>cryst</code> <p>The final crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>slmlist</code> <code>list of slm</code> <p>A list of SLMs, each represented by a triplet of integer matrices like <code>(hA, hB, q)</code>.</p> required <code>r</code> <code>(3, 3) array</code> <p>A rotation matrix representing the given orientation relationship.</p> required <code>uspfix</code> <code>bool</code> <p>Whether to fix the uniformed scaled plane. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>anglelist</code> <code>(...,) array</code> <p>Contains rotation angles that measure the difference of each SLM and the given orientation.</p>"},{"location":"api/#crystmatch.analysis.get_pure_rotation","title":"<code>get_pure_rotation(cryst, tol=0.001)</code>","text":"<p>Find all pure rotations appeared in the space group of <code>cryst</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cryst</code> <code>3 - tuple</code> <p><code>(lattice, species, positions)</code>, representing the crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>tol</code> <code>float</code> <p>The tolerance for <code>spglib</code> symmetry detection; default is 1e-3.</p> <code>0.001</code> <p>Returns:</p> Name Type Description <code>g</code> <code>(..., 3, 3) array of ints</code> <p>A point group of the first kind, containing all pure rotations appeared in the space group of <code>cryst</code>,             elements of which are integer matrices (under fractional coordinates).</p>"},{"location":"api/#crystmatch.analysis.hnf_int","title":"<code>hnf_int(m, return_q=True)</code>","text":"<p>Decompose square integer matrix <code>m</code> into product of HNF matrix <code>h</code> and unimodular matrix <code>q</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>(N, N) array of ints</code> <p>The integer matrix to decompose, with positive determinant.</p> required <code>return_q</code> <code>bool</code> <p>Whether to return the unimodular matrix <code>q</code>. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>h</code> <code>(N, N) array of ints</code> <p>The column-style Hermite normal form of <code>m</code>.</p> <code>q</code> <code>(N, N) array of ints</code> <p>The unimodular matrix satisfying <code>m</code> = <code>h @ q</code>.</p>"},{"location":"api/#crystmatch.analysis.hnf_rational","title":"<code>hnf_rational(m, max_divisor=10000)</code>","text":"<p>The Hermite normal form (HNF) of full-row-rank rational matrix <code>m</code> (not necessarily square or integer).</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>(M, N) array_like, M &lt;= N</code> <p>The full-row-rank rational matrix to reduce.</p> required <code>max_divisor</code> <code>int</code> <p>A positive integer. The least common multiple of all divisors in <code>m</code> should not be greater than <code>max_divisor</code>.</p> <code>10000</code> <p>Returns:</p> Name Type Description <code>h</code> <code>(M, N) array</code> <p>The HNF of <code>m</code> obtained via elementary column operations over integers.</p>"},{"location":"api/#crystmatch.analysis.int_arrays_to_pair","title":"<code>int_arrays_to_pair(crystA, crystB, slm, p, ks, centered=True)</code>","text":"<p>Convert the integer arrays representation <code>(slm, p, translations)</code> of a CSM to a pair of crysts.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slm</code> <code>slm</code> <p>The SLM of the CSM.</p> required <code>p</code> <code>(Z, ) array of ints</code> <p>The permutaion of the shuffle.</p> required <code>ks</code> <code>(3, Z) array of ints</code> <p>The lattice-vector translations of the shuffle.</p> required <code>centered</code> <code>bool</code> <p>Whether to make the centers of <code>crystA_sup</code> and <code>crystB_sup_final</code> coincide. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>crystA_sup</code> <code>cryst</code> <p>The initial structure, whose lattice vectors and atoms are matched to <code>crystB_sup</code> according to the CSM.</p> <code>crystB_sup_final</code> <code>cryst</code> <p>The final structure, whose lattice vectors and atoms are matched to <code>crystA_sup</code> according to the CSM, with rotation-free orientation.</p>"},{"location":"api/#crystmatch.analysis.int_fact","title":"<code>int_fact(n)</code>","text":"<p>Factorize positive integer <code>n</code> into products of two integers.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The integer to be factorized.</p> required <p>Returns:</p> Name Type Description <code>l</code> <code>list of 2-tuples of ints</code> <p>Contains all <code>(a, b)</code> such that a*b=n.</p>"},{"location":"api/#crystmatch.analysis.int_vec_inside","title":"<code>int_vec_inside(c)</code>","text":"<p>Integer vectors inside the cell <code>c</code> whose elements are integers.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array of ints</code> <p>A matrix whose columns are integer cell vectors.</p> required <p>Returns:</p> Name Type Description <code>v_int</code> <code>(3, ...) array of ints</code> <p>Its columns are vectors satisfying <code>v = c @ k</code>, where <code>k[0]</code>, <code>k[1]</code>, <code>k[2]</code> \\(\\in [0, 1)\\).</p>"},{"location":"api/#crystmatch.analysis.load_poscar","title":"<code>load_poscar(filename, to_primitive=True, tol=0.001, verbose=True)</code>","text":"<p>Load the crystal structure from a POSCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the POSCAR file to be read.</p> required <code>to_primitive</code> <code>bool</code> <p>Using the primitive cell instead of the cell given by the POSCAR file. Default is True.</p> <code>True</code> <code>tol</code> <code>str</code> <p>The tolerance for <code>spglib</code> symmetry detection; default is 1e-3.</p> <code>0.001</code> <p>Returns:</p> Name Type Description <code>cryst</code> <code>cryst</code> <p>The loaded crystal structure, consisting of the lattice vectors, species, and positions.</p>"},{"location":"api/#crystmatch.analysis.matrix_gcd","title":"<code>matrix_gcd(m1, m2, max_divisor=10000)</code>","text":"<p>Return a greatest common divisor of rational matrices <code>m1</code> and <code>m2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m1</code> <code>(3, 3) array_like</code> <p>Nonsingular rational matrices.</p> required <code>m2</code> <code>(3, 3) array_like</code> <p>Nonsingular rational matrices.</p> required <code>max_divisor</code> <code>int</code> <p>A positive integer. The least common multiple of all divisors in <code>m</code> should not be greater than <code>max_divisor</code>.</p> <code>10000</code> <p>Returns:</p> Name Type Description <code>d</code> <code>(3, 3) array</code> <p>The greatest common divisor of <code>m1</code> and <code>m2</code> in Hermite normal form.</p>"},{"location":"api/#crystmatch.analysis.matrix_lcm","title":"<code>matrix_lcm(m1, m2)</code>","text":"<p>Return a least common multiple of integer matrices <code>m1</code> and <code>m2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m1</code> <code>(3, 3) array_like</code> <p>Nonsingular integer matrices.</p> required <code>m2</code> <code>(3, 3) array_like</code> <p>Nonsingular integer matrices.</p> required <p>Returns:</p> Name Type Description <code>m</code> <code>(3, 3) array</code> <p>The least common multiple of <code>m1</code> and <code>m2</code> in Hermite normal form.</p>"},{"location":"api/#crystmatch.analysis.multiplicity","title":"<code>multiplicity(crystA, crystB, slmlist)</code>","text":"<p>Return multiplicities of elements in <code>slmlist</code>.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>crystB</code> <code>cryst</code> <p>The final crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>slmlist</code> <code>list of slm</code> <p>A list of SLMs, each represented by a triplet of integer matrices like <code>(hA, hB, q)</code>.</p> required <p>Returns:</p> Name Type Description <code>mu</code> <code>int or (...,) array of ints</code> <p>Multiplicities of each SLM in <code>slmlist</code>.</p>"},{"location":"api/#crystmatch.analysis.orient_matrix","title":"<code>orient_matrix(vi, vf, wi, wf)</code>","text":"<p>Rotation matrix <code>r</code> such that <code>r @ vi</code> || <code>vf</code> and <code>r @ wi</code> || <code>wf</code>.</p> <p>Parameters:</p> Name Type Description Default <code>vi</code> <code>(3,) array_like</code> <p>Vectors (cartesian coordinates) that satisfy <code>r @ vi</code> || <code>vf</code>.</p> required <code>vf</code> <code>(3,) array_like</code> <p>Vectors (cartesian coordinates) that satisfy <code>r @ vi</code> || <code>vf</code>.</p> required <code>wi</code> <code>(3,) array_like</code> <p>Vectors (cartesian coordinates) that satisfy <code>r @ wi</code> || <code>wf</code>.</p> required <code>wf</code> <code>(3,) array_like</code> <p>Vectors (cartesian coordinates) that satisfy <code>r @ wi</code> || <code>wf</code>.</p> required <p>Returns:</p> Name Type Description <code>r</code> <code>(3, 3) array</code> <p>A rotation matrix representing the given orientation relationship.</p>"},{"location":"api/#crystmatch.analysis.rmss","title":"<code>rmss(slist)</code>","text":"<p>Root-mean-square strains of given deformation gradient matrices.</p> <p>Parameters:</p> Name Type Description Default <code>slist</code> <code>(..., 3, 3) array</code> <p>A list of deformation gradient matrices.</p> required <p>Returns:</p> Name Type Description <code>rmss</code> <code>(...) array</code> <p>Root-mean-square strains.</p>"},{"location":"api/#crystmatch.analysis.save_interpolation","title":"<code>save_interpolation(filename, crystA_sup, crystB_sup, images=10, crystname=None)</code>","text":"<p>Save the linear interpolation between <code>crystA</code> and <code>crystB</code> to a single XDATCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save, must not already exist in current directory.</p> required <code>crystA_sup</code> <code>cryst</code> <p>The initial and final crystal structures with specified atomic correspondence, usually obtained by <code>minimize_rmsd</code>.</p> required <code>crystB_sup</code> <code>cryst</code> <p>The initial and final crystal structures with specified atomic correspondence, usually obtained by <code>minimize_rmsd</code>.</p> required <code>images</code> <code>int</code> <p>Number of images to generate. Default is 10.</p> <code>10</code> <code>crystname</code> <code>str</code> <p>A system description to write to the comment line of the POSCAR file. If <code>crystname = None</code>, <code>filename</code> will be used.</p> <code>None</code>"},{"location":"api/#crystmatch.analysis.save_poscar","title":"<code>save_poscar(filename, cryst, crystname=None)</code>","text":"<p>Save the crystal structure to a POSCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save, must not already exist in current directory. If <code>filename = None</code>, a string will be returned instead.</p> required <code>cryst</code> <code>cryst</code> <p>The crystal structure to be saved, consisting of the lattice vectors, species, and positions.</p> required <code>crystname</code> <code>str</code> <p>A system description to write to the comment line of the POSCAR file. If <code>crystname = None</code>, <code>filename</code> will be used.</p> <code>None</code>"},{"location":"api/#crystmatch.analysis.save_scatter","title":"<code>save_scatter(filename, rmsslist, rmsdlist, colorlist, cmap=plt.cm.get_cmap('viridis'), cbarlabel=None)</code>","text":"<p>Scatter plot of the CSMs with colorbar.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the saved plot.</p> required <code>rmsslist</code> <code>(N,) array_like</code> <p>The root-mean-square strain of each CSM.</p> required <code>rmsdlist</code> <code>(N,) array_like</code> <p>The root-mean-square distance of each CSM.</p> required <code>colorlist</code> <code>(N,) array_like</code> <p>Some quantity of each CSM, which is to be colored.</p> required <code>cmap</code> <code>`matplotlib.colors.Colormap`</code> <p>The colormap to use. Default is <code>plt.cm.get_cmap('viridis')</code>.</p> <code>get_cmap('viridis')</code> <code>cbarlabel</code> <code>str</code> <p>The label of the colorbar. Default is None, in which case the filename is used.</p> <code>None</code>"},{"location":"api/#crystmatch.analysis.sing_val","title":"<code>sing_val(crystA, crystB, slmlist)</code>","text":"<p>Return singular values of elements in <code>slmlist</code>.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>crystB</code> <code>cryst</code> <p>The final crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>slmlist</code> <code>list of slm</code> <p>A list of SLMs, each represented by a triplet of integer matrices like <code>(hA, hB, q)</code>.</p> required <p>Returns:</p> Name Type Description <code>sv</code> <code>(..., 3) array</code> <p>Contains singular values of each SLM in <code>slmlist</code>.</p>"},{"location":"api/#crystmatch.analysis.species_poscar_format","title":"<code>species_poscar_format(species)</code>","text":"<p>Examine whether a species array is sorted. If so, convert it to the POSCAR format.</p> <p>Parameters:</p> Name Type Description Default <code>species</code> <code>(N,) array of str</code> <p>The species array.</p> required <p>Returns:</p> Name Type Description <code>species_unique</code> <code>(M,) array of str</code> <p>The unique species in the order of their first appearance in <code>species</code>.</p> <code>species_counts</code> <code>(M,) array of int</code> <p>The number of occurrences of each unique species in <code>species</code>.</p>"},{"location":"api/#crystmatch.analysis.unique_filename","title":"<code>unique_filename(message, filename)</code>","text":"<p>Get a unique filename by appending a number to the end of the given filename.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to be modified.</p> required <code>message</code> <code>str</code> <p>A message to print before the filename.</p> required <p>Returns:</p> Name Type Description <code>new_filename</code> <code>str</code> <p>The modified filename with a unique number appended.</p>"},{"location":"api/#crystmatch.analysis.vector_reduce","title":"<code>vector_reduce(v, divisors)</code>","text":"<p>Minimizing the norm of <code>v</code> by adding and subtracting columns of <code>divisors</code>.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>(N,) array</code> <p>The vector to be reduced.</p> required <code>divisors</code> <code>(N, ...) array</code> <p>The vectors used to translate <code>v</code>.</p> required <p>Returns:</p> Name Type Description <code>vv</code> <code>(N,) array</code> <p>The reduced <code>v</code> with minimum Euclidean norm.</p>"},{"location":"api/#crystmatch.utilities","title":"<code>crystmatch.utilities</code>","text":"<p>Load/save crystal structures and CSMs from/to files.</p>"},{"location":"api/#crystmatch.utilities.all_hnf","title":"<code>all_hnf(det)</code>","text":"<p>Enumerate all 3*3 column Hermite normal forms (HNFs) with given determinant.</p> <p>Parameters:</p> Name Type Description Default <code>det</code> <code>int</code> <p>The determinant of HNFs.</p> required <p>Returns:</p> Name Type Description <code>l</code> <code>(..., 3, 3) array of ints</code> <p>Contains all HNFs with determinant <code>det</code>.</p>"},{"location":"api/#crystmatch.utilities.cell_reduce","title":"<code>cell_reduce(c)</code>","text":"<p>Shorten the cell vectors of <code>c</code>.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array</code> <p>The cell to be reduced, whose columns are cell vectors.</p> required <p>Returns:</p> Name Type Description <code>cc</code> <code>(3, 3) array</code> <p>The Niggli cell, with shortest right-handed cell vectors.</p> <code>q</code> <code>(3, 3) array of ints</code> <p>The unimodular matrix satisfying <code>cc = c @ q</code>.</p>"},{"location":"api/#crystmatch.utilities.create_common_supercell","title":"<code>create_common_supercell(crystA, crystB, slm)</code>","text":"<p>Create supercell structures representing \\(\\mathcal{A}\\) (initial structure)and \\(\\sqrt{S^{\\text{T}} S}S^{-1}\\mathcal{B}\\)         (rotation-free final structure). Also return the half-distorted supercell and translation cell.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slm</code> <code>slm</code> <p>The SLM of the CSM.</p> required <p>Returns:</p> Name Type Description <code>crystA_sup</code> <code>cryst</code> <p>The supercell of \\(\\mathcal{A}\\).</p> <code>crystB_sup_final</code> <code>cryst</code> <p>The supercell of \\(\\sqrt{S^{\\text{T}} S}\\mathcal{A}\\), which equals the supercell of \\((S^{\\text{T}} S)^{-1/2}\\mathcal{B}\\).</p> <code>c_sup_half</code> <code>(3, 3) array of floats</code> <p>The half-distorted supercell, which equals the supercel of \\((S^{\\text{T}} S)^{1/4}\\mathcal{A}\\) and that of \\((S^{\\text{T}} S)^{-1/4}\\mathcal{B}\\).</p> <code>f_translate</code> <code>(3, 3) array of floats</code> <p>The translation cell (fractional coordinates) of the shuffle whose lattice is generated by<code>c_sup_half</code>.</p>"},{"location":"api/#crystmatch.utilities.deformation_gradient","title":"<code>deformation_gradient(crystA, crystB, slmlist)</code>","text":"<p>Compute the deformation gradient matrices of given IMTs.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slmlist</code> <code>list of slm</code> <p>The IMTs.</p> required <p>Returns:</p> Name Type Description <code>slist</code> <code>(..., 3, 3) array</code> <p>A list of deformation gradient matrices.</p>"},{"location":"api/#crystmatch.utilities.get_pure_rotation","title":"<code>get_pure_rotation(cryst, tol=0.001)</code>","text":"<p>Find all pure rotations appeared in the space group of <code>cryst</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cryst</code> <code>3 - tuple</code> <p><code>(lattice, species, positions)</code>, representing the crystal structure, usually obtained by <code>load_poscar</code>.</p> required <code>tol</code> <code>float</code> <p>The tolerance for <code>spglib</code> symmetry detection; default is 1e-3.</p> <code>0.001</code> <p>Returns:</p> Name Type Description <code>g</code> <code>(..., 3, 3) array of ints</code> <p>A point group of the first kind, containing all pure rotations appeared in the space group of <code>cryst</code>,             elements of which are integer matrices (under fractional coordinates).</p>"},{"location":"api/#crystmatch.utilities.hnf_int","title":"<code>hnf_int(m, return_q=True)</code>","text":"<p>Decompose square integer matrix <code>m</code> into product of HNF matrix <code>h</code> and unimodular matrix <code>q</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>(N, N) array of ints</code> <p>The integer matrix to decompose, with positive determinant.</p> required <code>return_q</code> <code>bool</code> <p>Whether to return the unimodular matrix <code>q</code>. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>h</code> <code>(N, N) array of ints</code> <p>The column-style Hermite normal form of <code>m</code>.</p> <code>q</code> <code>(N, N) array of ints</code> <p>The unimodular matrix satisfying <code>m</code> = <code>h @ q</code>.</p>"},{"location":"api/#crystmatch.utilities.hnf_rational","title":"<code>hnf_rational(m, max_divisor=10000)</code>","text":"<p>The Hermite normal form (HNF) of full-row-rank rational matrix <code>m</code> (not necessarily square or integer).</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>(M, N) array_like, M &lt;= N</code> <p>The full-row-rank rational matrix to reduce.</p> required <code>max_divisor</code> <code>int</code> <p>A positive integer. The least common multiple of all divisors in <code>m</code> should not be greater than <code>max_divisor</code>.</p> <code>10000</code> <p>Returns:</p> Name Type Description <code>h</code> <code>(M, N) array</code> <p>The HNF of <code>m</code> obtained via elementary column operations over integers.</p>"},{"location":"api/#crystmatch.utilities.int_arrays_to_pair","title":"<code>int_arrays_to_pair(crystA, crystB, slm, p, ks, centered=True)</code>","text":"<p>Convert the integer arrays representation <code>(slm, p, translations)</code> of a CSM to a pair of crysts.</p> <p>Parameters:</p> Name Type Description Default <code>crystA</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>crystB</code> <code>cryst</code> <p>The initial and final structures.</p> required <code>slm</code> <code>slm</code> <p>The SLM of the CSM.</p> required <code>p</code> <code>(Z, ) array of ints</code> <p>The permutaion of the shuffle.</p> required <code>ks</code> <code>(3, Z) array of ints</code> <p>The lattice-vector translations of the shuffle.</p> required <code>centered</code> <code>bool</code> <p>Whether to make the centers of <code>crystA_sup</code> and <code>crystB_sup_final</code> coincide. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>crystA_sup</code> <code>cryst</code> <p>The initial structure, whose lattice vectors and atoms are matched to <code>crystB_sup</code> according to the CSM.</p> <code>crystB_sup_final</code> <code>cryst</code> <p>The final structure, whose lattice vectors and atoms are matched to <code>crystA_sup</code> according to the CSM, with rotation-free orientation.</p>"},{"location":"api/#crystmatch.utilities.int_fact","title":"<code>int_fact(n)</code>","text":"<p>Factorize positive integer <code>n</code> into products of two integers.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The integer to be factorized.</p> required <p>Returns:</p> Name Type Description <code>l</code> <code>list of 2-tuples of ints</code> <p>Contains all <code>(a, b)</code> such that a*b=n.</p>"},{"location":"api/#crystmatch.utilities.int_vec_inside","title":"<code>int_vec_inside(c)</code>","text":"<p>Integer vectors inside the cell <code>c</code> whose elements are integers.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>(3, 3) array of ints</code> <p>A matrix whose columns are integer cell vectors.</p> required <p>Returns:</p> Name Type Description <code>v_int</code> <code>(3, ...) array of ints</code> <p>Its columns are vectors satisfying <code>v = c @ k</code>, where <code>k[0]</code>, <code>k[1]</code>, <code>k[2]</code> \\(\\in [0, 1)\\).</p>"},{"location":"api/#crystmatch.utilities.load_poscar","title":"<code>load_poscar(filename, to_primitive=True, tol=0.001, verbose=True)</code>","text":"<p>Load the crystal structure from a POSCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the POSCAR file to be read.</p> required <code>to_primitive</code> <code>bool</code> <p>Using the primitive cell instead of the cell given by the POSCAR file. Default is True.</p> <code>True</code> <code>tol</code> <code>str</code> <p>The tolerance for <code>spglib</code> symmetry detection; default is 1e-3.</p> <code>0.001</code> <p>Returns:</p> Name Type Description <code>cryst</code> <code>cryst</code> <p>The loaded crystal structure, consisting of the lattice vectors, species, and positions.</p>"},{"location":"api/#crystmatch.utilities.matrix_gcd","title":"<code>matrix_gcd(m1, m2, max_divisor=10000)</code>","text":"<p>Return a greatest common divisor of rational matrices <code>m1</code> and <code>m2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m1</code> <code>(3, 3) array_like</code> <p>Nonsingular rational matrices.</p> required <code>m2</code> <code>(3, 3) array_like</code> <p>Nonsingular rational matrices.</p> required <code>max_divisor</code> <code>int</code> <p>A positive integer. The least common multiple of all divisors in <code>m</code> should not be greater than <code>max_divisor</code>.</p> <code>10000</code> <p>Returns:</p> Name Type Description <code>d</code> <code>(3, 3) array</code> <p>The greatest common divisor of <code>m1</code> and <code>m2</code> in Hermite normal form.</p>"},{"location":"api/#crystmatch.utilities.matrix_lcm","title":"<code>matrix_lcm(m1, m2)</code>","text":"<p>Return a least common multiple of integer matrices <code>m1</code> and <code>m2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>m1</code> <code>(3, 3) array_like</code> <p>Nonsingular integer matrices.</p> required <code>m2</code> <code>(3, 3) array_like</code> <p>Nonsingular integer matrices.</p> required <p>Returns:</p> Name Type Description <code>m</code> <code>(3, 3) array</code> <p>The least common multiple of <code>m1</code> and <code>m2</code> in Hermite normal form.</p>"},{"location":"api/#crystmatch.utilities.rmss","title":"<code>rmss(slist)</code>","text":"<p>Root-mean-square strains of given deformation gradient matrices.</p> <p>Parameters:</p> Name Type Description Default <code>slist</code> <code>(..., 3, 3) array</code> <p>A list of deformation gradient matrices.</p> required <p>Returns:</p> Name Type Description <code>rmss</code> <code>(...) array</code> <p>Root-mean-square strains.</p>"},{"location":"api/#crystmatch.utilities.save_poscar","title":"<code>save_poscar(filename, cryst, crystname=None)</code>","text":"<p>Save the crystal structure to a POSCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save, must not already exist in current directory. If <code>filename = None</code>, a string will be returned instead.</p> required <code>cryst</code> <code>cryst</code> <p>The crystal structure to be saved, consisting of the lattice vectors, species, and positions.</p> required <code>crystname</code> <code>str</code> <p>A system description to write to the comment line of the POSCAR file. If <code>crystname = None</code>, <code>filename</code> will be used.</p> <code>None</code>"},{"location":"api/#crystmatch.utilities.species_poscar_format","title":"<code>species_poscar_format(species)</code>","text":"<p>Examine whether a species array is sorted. If so, convert it to the POSCAR format.</p> <p>Parameters:</p> Name Type Description Default <code>species</code> <code>(N,) array of str</code> <p>The species array.</p> required <p>Returns:</p> Name Type Description <code>species_unique</code> <code>(M,) array of str</code> <p>The unique species in the order of their first appearance in <code>species</code>.</p> <code>species_counts</code> <code>(M,) array of int</code> <p>The number of occurrences of each unique species in <code>species</code>.</p>"},{"location":"api/#crystmatch.utilities.unique_filename","title":"<code>unique_filename(message, filename)</code>","text":"<p>Get a unique filename by appending a number to the end of the given filename.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to be modified.</p> required <code>message</code> <code>str</code> <p>A message to print before the filename.</p> required <p>Returns:</p> Name Type Description <code>new_filename</code> <code>str</code> <p>The modified filename with a unique number appended.</p>"},{"location":"api/#crystmatch.utilities.vector_reduce","title":"<code>vector_reduce(v, divisors)</code>","text":"<p>Minimizing the norm of <code>v</code> by adding and subtracting columns of <code>divisors</code>.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>(N,) array</code> <p>The vector to be reduced.</p> required <code>divisors</code> <code>(N, ...) array</code> <p>The vectors used to translate <code>v</code>.</p> required <p>Returns:</p> Name Type Description <code>vv</code> <code>(N,) array</code> <p>The reduced <code>v</code> with minimum Euclidean norm.</p>"},{"location":"cli/","title":"Command-line interface","text":"<pre><code>flowchart TB\n  A{mode?} --&gt; |\"&lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; word-break: break-word;'&gt;--enumeration&lt;/code&gt;\"| B[enumerate a list of&lt;br&gt;representative CSMs];\n  B --&gt; E[save CSMs to NPZ file];\n  E --&gt; F;\n  A --&gt; |\"&lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; word-break: break-word;'&gt;--read&lt;/code&gt;\"| C[\"read CSMs from NPZ file&lt;br&gt;(after &lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; word-break: break-word;'&gt;--enumeration&lt;/code&gt;)\"];\n  C --&gt; G[\"export CSM to POSCAR&lt;br&gt;files if &lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; word-break: break-word;'&gt;--export&lt;/code&gt;\"];\n  G --&gt; F;\n  A --&gt; |\"&lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; word-break: break-word;'&gt;--single&lt;/code&gt;\"| D[\"read a single CSM from&lt;br&gt;&lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; word-break: break-word;'&gt;-I&lt;/code&gt; and &lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; word-break: break-word;'&gt;-F&lt;/code&gt; POSCAR files\"];\n  D --&gt; F[\"analyze orientation&lt;br&gt;if &lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; word-break: break-word;'&gt;--orientation&lt;/code&gt;\"];\n  F --&gt; I[\"generate reports according&lt;br&gt;to &lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; word-break: break-word;'&gt;--csv&lt;/code&gt; and &lt;code style='color: #dd0099 !important; background-color: var(--md-code-bg-color); border-radius: .1rem; font-size: .85em; padding: 0 .2941176471em; word-break: break-word;'&gt;--plot&lt;/code&gt;\"];</code></pre> <p>The <code>crystmatch</code> command-line interface is already introduced in Tutorial. Here, we provide a table of all available options:</p> Option Description Mode <code>-h</code>, <code>--help</code> Show help message and exit. none <code>-V</code>, <code>-v</code>, <code>--version</code> Show program's version number and exit. none <code>-E MAX_MU MAX_RMSS</code><code>--enumeration MAX_MU MAX_RMSS</code> Use 'enumeration' mode, with <code>MAX_MU</code> and <code>MAX_RMSS</code> as the multiplicity and RMSS upper bounds. 'enumeration' <code>-R CSM_LIST</code><code>--read CSM_LIST</code> Use 'read' mode, with CSMs loaded from an existing NPZ file <code>CSM_LIST</code>. 'read' <code>-S</code><code>--single</code> Use 'single-CSM' mode, with the CSM uniquely determined by <code>-I</code> and <code>-F</code>. 'single-CSM' <code>-I POSCAR_I</code><code>--initial POSCAR_I</code> POSCAR file of the initial crystal structure. 'enumeration', 'single-CSM' <code>-F POSCAR_F</code><code>--final POSCAR_F</code> POSCAR file of the final crystal structure. 'enumeration', 'single-CSM' <code>-e INDEX1 [INDEX2 ...]</code><code>--export INDEX1 [INDEX2 ...]</code> Export CSMs from NPZ file with the given indices. 'read' <code>-i [IMAGES]</code><code>--interpolate [IMAGES]</code> Create XDATCAR files when <code>-e</code> or <code>--export</code> is used. <code>IMAGES</code> is the number of images to be added; default is 10. 'read' <code>-t TOL</code><code>--tolerance TOL</code> Tolerance for determining crystal symmetry; default is 1e-3. 'enumeration', 'single-CSM' <code>-o vix viy viz vfx vfy vfz wix wiy wiz wfx wfy wfz</code><code>--orientation vix viy viz vfx vfy vfz wix wiy wiz wfx wfy wfz</code> Benchmark CSMs by their deviation angles from the orientation relationship: \"\\(\\mathbf{v}_\\text{i}\\parallel\\mathbf{v}_\\text{f}\\) and \\(\\mathbf{w}_\\text{i}\\parallel\\mathbf{w}_\\text{f}\\)\".Note: arguments must be given in Cartesian coordinates. all <code>-c</code>, <code>--csv</code> Create CSV file. all <code>-p</code>, <code>--plot</code> Create scatter plot. all <code>-u</code>, <code>--uspfix</code> Use USP-fixed manner in <code>--orientation</code>. all"}]}